# creativity/__init__.py
"""
Syst√®me de Cr√©ativit√© Avanc√©e de l'AGI √âvolutive
G√©n√©ration d'id√©es, m√©lange conceptuel, d√©tection d'insights et innovation int√©gr√©s
"""

import numpy as np
import time
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple, Set, Callable
from dataclasses import dataclass, field
from enum import Enum
import threading
from collections import defaultdict, deque
import math
import random
import networkx as nx
from itertools import combinations, product
import re

class CreativityMode(Enum):
    """Modes de fonctionnement cr√©atif"""
    DIVERGENT_THINKING = "pens√©e_divergente"
    CONVERGENT_THINKING = "pens√©e_convergente"
    LATERAL_THINKING = "pens√©e_lat√©rale"
    SYSTEMS_THINKING = "pens√©e_syst√©mique"
    INTUITIVE_THINKING = "pens√©e_intuitive"

class IdeaState(Enum):
    """√âtats du cycle de vie d'une id√©e"""
    RAW = "brute"
    DEVELOPED = "d√©velopp√©e"
    REFINED = "affin√©e"
    INTEGRATED = "int√©gr√©e"
    IMPLEMENTED = "impl√©ment√©e"
    ARCHIVED = "archiv√©e"

class InsightType(Enum):
    """Types d'insights cr√©atifs"""
    ASSOCIATIVE = "associatif"
    RESTRUCTURING = "restructuration"
    ANALOGICAL = "analogique"
    EMERGENT = "√©mergent"
    INTUITIVE = "intuitif"

@dataclass
class CreativeIdea:
    """Repr√©sentation compl√®te d'une id√©e cr√©ative"""
    id: str
    concept_core: str
    description: str
    state: IdeaState
    novelty: float                    # 0.0-1.0
    usefulness: float                 # 0.0-1.0
    feasibility: float                # 0.0-1.0
    elaboration: float                # 0.0-1.0
    domains: List[str]
    components: List[str]
    associations: List[str]
    created_time: float
    last_modified: float
    development_history: List[Dict[str, Any]]
    emotional_affinity: float         # Affinit√© √©motionnelle avec l'id√©e
    activation_level: float           # Niveau d'activation dans l'espace conceptuel

@dataclass
class ConceptualBlend:
    """M√©lange conceptuel cr√©atif"""
    blend_id: str
    input_spaces: List[str]           # Espaces conceptuels d'entr√©e
    generic_space: List[str]          # Espace g√©n√©rique commun
    blended_space: str                # Espace conceptuel r√©sultant
    emergent_structure: List[str]     # Structure √©mergente
    creativity_score: float
    coherence: float
    elaboration_potential: float

@dataclass
class CreativeInsight:
    """Insight cr√©atif moment "Eur√™ka"""
    insight_id: str
    type: InsightType
    content: str
    significance: float
    clarity: float
    surprise: float
    emotional_intensity: float
    preceding_incubation: float       # Dur√©e d'incubation pr√©c√©dente
    trigger: str
    timestamp: float
    related_ideas: List[str]
    verification_status: str          # "unverified", "verified", "falsified"

@dataclass
class InnovationProject:
    """Projet d'innovation structur√©"""
    project_id: str
    core_idea: str
    objectives: List[str]
    constraints: List[str]
    resources_needed: List[str]
    development_phases: List[Dict[str, Any]]
    current_phase: int
    success_metrics: Dict[str, float]
    risk_assessment: Dict[str, float]
    team_dynamics: Dict[str, Any]     # Pour collaboration future

class CreativitySystem:

    def _ensure_idea_struct(idea):
        if isinstance(idea, str):
            return {'raw_text': idea, 'state': 'RAW'}
        return idea
    """
    Syst√®me de cr√©ativit√© inspir√© des processus cognitifs humains
    Int√®gre g√©n√©ration, incubation, illumination et v√©rification
    """
    
    def __init__(self, cognitive_architecture=None, memory_system=None, 
                 reasoning_system=None, emotional_system=None, metacognitive_system=None):
        self.cognitive_architecture = cognitive_architecture
        self.memory_system = memory_system
        self.reasoning_system = reasoning_system
        self.emotional_system = emotional_system
        self.metacognitive_system = metacognitive_system
        self.creation_time = time.time()

        # ‚Äî‚Äî‚Äî LIAISONS INTER-MODULES ‚Äî‚Äî‚Äî
        if self.cognitive_architecture:
            self.goals = getattr(self.cognitive_architecture, "goals", None)
            self.learning = getattr(self.cognitive_architecture, "learning", None)
            self.perception = getattr(self.cognitive_architecture, "perception", None)
            self.world_model = getattr(self.cognitive_architecture, "world_model", None)

        
        # === ESPACE CONCEPTUEL DYNAMIQUE ===
        self.conceptual_space = {
            "concept_network": nx.Graph(),
            "semantic_density": defaultdict(float),
            "conceptual_distance": defaultdict(float),
            "activation_spreading": ActivationSpreadingSystem(),
            "constraint_relaxation": ConstraintRelaxationSystem()
        }
        
        # === MOTEUR DE G√âN√âRATION D'ID√âES ===
        self.idea_generation = {
            "divergent_thinker": DivergentThinker(),
            "convergent_thinker": ConvergentThinker(),
            "lateral_thinker": LateralThinker(),
            "idea_pool": deque(maxlen=1000),
            "idea_quality_metrics": IdeaQualityMetrics(),
            "generation_strategies": self._initialize_generation_strategies()
        }
        
        # === SYST√àME DE M√âLANGE CONCEPTUEL ===
        self.conceptual_blending = {
            "blending_engine": ConceptualBlendingEngine(),
            "cross_domain_mapper": CrossDomainMapper(),
            "emergent_structure_detector": EmergentStructureDetector(),
            "blend_evaluator": BlendEvaluator(),
            "blend_history": deque(maxlen=500)
        }
        
        # === M√âCANISME D'INSIGHT ===
        self.insight_detection = {
            "incubation_monitor": IncubationMonitor(),
            "insight_triggers": InsightTriggerSystem(),
            "aha_moment_detector": AhaMomentDetector(),
            "verification_system": InsightVerificationSystem(),
            "insight_history": deque(maxlen=200)
        }
        
        # === MOTEUR D'INNOVATION ===
        self.innovation_engine = {
            "project_manager": InnovationProjectManager(),
            "development_planner": DevelopmentPlanner(),
            "risk_assessor": InnovationRiskAssessor(),
            "collaboration_simulator": CollaborationSimulator(),
            "innovation_pipeline": deque(maxlen=50)
        }
        
        # === PROCESSUS CR√âATIFS ===
        self.creative_processes = {
            "preparation": PreparationPhase(),
            "incubation": IncubationPhase(),
            "illumination": IlluminationPhase(),
            "verification": VerificationPhase(),
            "current_phase": "preparation",
            "phase_transitions": deque(maxlen=100)
        }
        
        # === √âTATS CR√âATIFS ===
        self.creative_states = {
            "creative_flow": 0.3,          # √âtat de flux cr√©atif
            "cognitive_flexibility": 0.5,  # Flexibilit√© cognitive
            "remote_associations": 0.4,    # Capacit√© d'associations √©loign√©es
            "conceptual_fluidity": 0.6,    # Fluidit√© conceptuelle
            "inspiration_level": 0.4,      # Niveau d'inspiration
            "creative_confidence": 0.5     # Confiance cr√©ative
        }
        
        # === INFLUENCES CONTEXTUELLES ===
        self.contextual_influences = {
            "environmental_stimuli": [],
            "cultural_constraints": [],
            "domain_knowledge": {},
            "emotional_climate": 0.5,
            "cognitive_load": 0.3,
            "time_pressure": 0.2
        }
        
        # === BASE DE CONNAISSANCES CR√âATIVE ===
        self.creative_knowledge = {
            "heuristics": self._initialize_creative_heuristics(),
            "analogical_sources": self._initialize_analogical_sources(),
            "constraint_templates": self._initialize_constraint_templates(),
            "innovation_patterns": self._initialize_innovation_patterns()
        }
        
        # === HISTORIQUE CR√âATIF ===
        self.creative_history = {
            "ideas_generated": deque(maxlen=5000),
            "blends_created": deque(maxlen=1000),
            "insights_experienced": deque(maxlen=500),
            "projects_completed": deque(maxlen=100),
            "creative_breakthroughs": deque(maxlen=50),
            "learning_trajectory": deque(maxlen=1000)
        }
        
        # === PARAM√àTRES DE FONCTIONNEMENT ===
        self.operational_parameters = {
            "divergence_threshold": 0.7,       # Seuil pour la pens√©e divergente
            "convergence_threshold": 0.6,      # Seuil pour la pens√©e convergente
            "blending_aggressiveness": 0.5,    # Agressivit√© du m√©lange conceptuel
            "insight_sensitivity": 0.6,        # Sensibilit√© aux insights
            "risk_tolerance": 0.4,             # Tol√©rance au risque innovant
            "elaboration_depth": 0.5           # Profondeur d'√©laboration
        }
        
        # === THREADS DE TRAITEMENT ===
        self.processing_threads = {}
        self.running = True
        
        # Initialisation des syst√®mes
        self._initialize_creativity_system()
        
        print("üé® Syst√®me de Cr√©ativit√© Initialis√©")
    
    def _initialize_creativity_system(self):
        """Initialise le syst√®me de cr√©ativit√© avec des capacit√©s de base"""
        
        # R√©seau conceptuel initial
        self._initialize_basic_conceptual_network()
        
        # Heuristiques cr√©atives inn√©es
        self._initialize_innate_creativity()
        
        # D√©marrage des processus d'arri√®re-plan
        self._start_creative_monitoring()
        self._start_incubation_process()
        self._start_insight_detection()
        
        # Premier cycle cr√©atif
        self._initiate_first_creative_cycle()
    
    def _initialize_basic_conceptual_network(self):
        """Initialise le r√©seau conceptuel de base"""
        concept_network = conceptual_space["concept_network"] if isinstance(conceptual_space, dict) else getattr(conceptual_space, "concept_network", None)
        
        # Concepts fondamentaux
        basic_concepts = [
            "espace", "temps", "mouvement", "√©nergie", "forme", 
            "couleur", "son", "texture", "quantit√©", "qualit√©",
            "relation", "causalit√©", "similarit√©", "diff√©rence",
            "partie", "tout", "ordre", "chaos", "sym√©trie", "asym√©trie"
        ]
        
        # Ajout des concepts au r√©seau
        for concept in basic_concepts:
            concept_network.add_node(concept, activation=0.1, domain="fondamental")
        
        # Connexions basiques entre concepts
        basic_connections = [
            ("espace", "temps"), ("mouvement", "√©nergie"), 
            ("forme", "couleur"), ("partie", "tout"),
            ("ordre", "chaos"), ("sym√©trie", "asym√©trie"),
            ("relation", "causalit√©"), ("similarit√©", "diff√©rence")
        ]
        
        for concept1, concept2 in basic_connections:
            concept_network.add_edge(concept1, concept2, weight=0.8, type="fondamental")
        
        print(f"üìö R√©seau conceptuel initialis√© avec {len(basic_concepts)} concepts")
    
    def _initialize_innate_creativity(self):
        """Initialise les capacit√©s cr√©atives inn√©es"""
        
        # Heuristiques de g√©n√©ration inn√©es
        innate_heuristics = {
            "analogy": {
                "description": "Trouver des similarit√©s entre domaines diff√©rents",
                "effectiveness": 0.7,
                "cognitive_cost": 0.6
            },
            "combination": {
                "description": "Combiner des √©l√©ments existants de nouvelle mani√®re",
                "effectiveness": 0.8,
                "cognitive_cost": 0.5
            },
            "transformation": {
                "description": "Modifier les propri√©t√©s d'un concept",
                "effectiveness": 0.6,
                "cognitive_cost": 0.4
            },
            "abstraction": {
                "description": "Extraire l'essence en ignorant les d√©tails",
                "effectiveness": 0.5,
                "cognitive_cost": 0.7
            }
        }
        
        (creative_knowledge["heuristics"] if isinstance(creative_knowledge, dict) else getattr(creative_knowledge, "heuristics", None)).update(innate_heuristics)
        
        # Patterns d'innovation basiques
        basic_innovation_patterns = {
            "problem_solution": {
                "description": "Identifier un probl√®me et trouver une solution",
                "success_rate": 0.6,
                "applicability": 0.9
            },
            "improvement": {
                "description": "Am√©liorer quelque chose d'existant",
                "success_rate": 0.7,
                "applicability": 0.8
            }
        }
        
        (creative_knowledge["innovation_patterns"] if isinstance(creative_knowledge, dict) else getattr(creative_knowledge, "innovation_patterns", None)).update(basic_innovation_patterns)
    
    def _initialize_creative_heuristics(self) -> Dict[str, Dict[str, Any]]:
        """Initialise les heuristiques cr√©atives"""
        return {
            "brainstorming": {
                "description": "G√©n√©rer beaucoup d'id√©es sans jugement",
                "applicable_phases": ["preparation", "divergence"],
                "parameters": {"quantity_focus": 0.8, "judgment_suspension": 0.9}
            },
            "scamper": {
                "description": "Substituer, Combiner, Adapter, Modifier, Proposer d'autres utilisations, √âliminer, Renverser",
                "applicable_phases": ["development", "transformation"],
                "parameters": {"systematic_coverage": 0.7, "transformation_power": 0.6}
            },
            "mind_mapping": {
                "description": "Organiser visuellement les id√©es autour d'un concept central",
                "applicable_phases": ["organization", "structuration"],
                "parameters": {"visual_support": 0.8, "association_facilitation": 0.7}
            }
        }
    
    def _initialize_analogical_sources(self) -> Dict[str, List[str]]:
        """Initialise les sources analogiques de base"""
        return {
            "nature": ["√©cosyst√®me", "√©volution", "adaptation", "symbiose", "croissance"],
            "technologie": ["r√©seau", "interface", "automatisation", "optimisation", "innovation"],
            "art": ["composition", "harmonie", "contraste", "rythme", "expression"],
            "science": ["hypoth√®se", "exp√©rimentation", "th√©orie", "preuve", "d√©couverte"]
        }
    
    def _initialize_constraint_templates(self) -> Dict[str, Dict[str, Any]]:
        """Initialise les mod√®les de contraintes cr√©atives"""
        return {
            "resource_limitation": {
                "description": "Limitation des ressources disponibles",
                "creativity_boost": 0.6,
                "applicability": 0.8
            },
            "time_pressure": {
                "description": "Contrainte temporelle",
                "creativity_boost": 0.4,
                "applicability": 0.6
            },
            "functional_requirement": {
                "description": "Exigence fonctionnelle sp√©cifique",
                "creativity_boost": 0.5,
                "applicability": 0.9
            }
        }
    
    def _initialize_innovation_patterns(self) -> Dict[str, Dict[str, Any]]:
        """Initialise les patterns d'innovation reconnus"""
        return {
            "disruptive_innovation": {
                "description": "Innovation qui cr√©e un nouveau march√©",
                "risk_level": 0.8,
                "potential_reward": 0.9
            },
            "incremental_innovation": {
                "description": "Am√©lioration progressive de l'existant",
                "risk_level": 0.3,
                "potential_reward": 0.5
            },
            "architectural_innovation": {
                "description": "Reconfiguration des composants existants",
                "risk_level": 0.5,
                "potential_reward": 0.7
            }
        }
    
    def _initialize_generation_strategies(self) -> Dict[str, Callable]:
        """Initialise les strat√©gies de g√©n√©ration d'id√©es"""
        return {
            "random_association": self._random_association_strategy,
            "domain_transfer": self._domain_transfer_strategy,
            "constraint_challenge": self._constraint_challenge_strategy,
            "attribute_listing": self._attribute_listing_strategy,
            "forced_relationship": self._forced_relationship_strategy
        }
    
    def _start_creative_monitoring(self):
        """D√©marre la surveillance cr√©ative continue"""
        def monitoring_loop():
            while self.running:
                try:
                    # Surveillance de l'√©tat cr√©atif
                    self._monitor_creative_state()
                    
                    # Mise √† jour de l'espace conceptuel
                    self._update_conceptual_space()
                    
                    # √âvaluation des id√©es en cours
                    self._evaluate_ongoing_ideas()
                    
                    # D√©tection d'opportunit√©s cr√©atives
                    self._detect_creative_opportunities()
                    
                    time.sleep(2)  # Surveillance toutes les 2 secondes
                    
                except Exception as e:
                    print(f"Erreur dans la surveillance cr√©ative: {e}")
                    time.sleep(5)
        
        monitor_thread = threading.Thread(target=monitoring_loop, daemon=True)
        monitor_thread.start()
if isinstance(processing_threads, dict):
    processing_threads['creative_monitoring'] = monitor_thread
else:
    setattr(processing_threads, 'creative_monitoring', monitor_thread)
    
    def _start_incubation_process(self):
        """D√©marre le processus d'incubation en arri√®re-plan"""
        def incubation_loop():
            while self.running:
                try:
                    # Traitement d'incubation des id√©es en attente
                    self._process_incubation_phase()
                    time.sleep(10)  # Traitement toutes les 10 secondes
                    
                except Exception as e:
                    print(f"Erreur dans le processus d'incubation: {e}")
                    time.sleep(30)
        
        incubation_thread = threading.Thread(target=incubation_loop, daemon=True)
        incubation_thread.start()
if isinstance(processing_threads, dict):
    processing_threads['incubation_process'] = incubation_thread
else:
    setattr(processing_threads, 'incubation_process', incubation_thread)
    
    def _start_insight_detection(self):
        """D√©marre la d√©tection d'insights en arri√®re-plan"""
        def insight_loop():
            while self.running:
                try:
                    # Surveillance des conditions d'insight
                    self._monitor_insight_conditions()
                    time.sleep(5)  # Surveillance toutes les 5 secondes
                    
                except Exception as e:
                    print(f"Erreur dans la d√©tection d'insights: {e}")
                    time.sleep(20)
        
        insight_thread = threading.Thread(target=insight_loop, daemon=True)
        insight_thread.start()
if isinstance(processing_threads, dict):
    processing_threads['insight_detection'] = insight_thread
else:
    setattr(processing_threads, 'insight_detection', insight_thread)
    
    def _initiate_first_creative_cycle(self):
        """Initie le premier cycle cr√©atif"""
        # G√©n√©ration d'id√©es initiales
        initial_ideas = self.generate_ideas(
            topic="cr√©ativit√©",
            constraints=[],
            num_ideas=5,
            strategy="random_association"
        )
        
        # Enregistrement du d√©but du cycle
if isinstance(creative_processes, dict):
    creative_processes['current_phase'] = "preparation"
else:
    setattr(creative_processes, 'current_phase', "preparation")
        (creative_history["learning_trajectory"] if isinstance(creative_history, dict) else getattr(creative_history, "learning_trajectory", None)).append({
            "timestamp": time.time(),
            "event": "first_creative_cycle_initiated",
            "ideas_generated": len(initial_ideas),
            "creative_state": self.creative_states.copy()
        })
    
    def generate_ideas(self, topic: str, constraints: List[str], 
                      num_ideas: int = 10, strategy: str = "auto") -> List[CreativeIdea]:
        """
        G√©n√®re de nouvelles id√©es cr√©atives
        """
        start_time = time.time()
        
        # S√©lection automatique de la strat√©gie si n√©cessaire
        if strategy == "auto":
            strategy = self._select_appropriate_strategy(topic, constraints)
        
        # Application de la strat√©gie s√©lectionn√©e
        generation_function = (idea_generation["generation_strategies"] if isinstance(idea_generation, dict) else getattr(idea_generation, "generation_strategies", None)).get(strategy)
        if not generation_function:
            generation_function = self._random_association_strategy
        
        raw_ideas = generation_function(topic, constraints, num_ideas)
        
        # Transformation en objets CreativeIdea
        developed_ideas = []
        for i, raw_idea in enumerate(raw_ideas):
            idea = self._develop_raw_idea(raw_idea, topic, constraints)
            developed_ideas.append(idea)
            
            # Ajout au pool d'id√©es
if isinstance(idea_generation, dict):
    idea_generation['idea_pool'].append(idea)
else:
    getattr(idea_generation, 'idea_pool', []).append(idea)
if isinstance(creative_history, dict):
    creative_history['ideas_generated'].append(idea)
else:
    getattr(creative_history, 'ideas_generated', []).append(idea)
        
        # Mise √† jour des m√©triques
        generation_time = time.time() - start_time
        self._update_creative_metrics(len(developed_ideas), generation_time, strategy)
        
        return developed_ideas
    
    def _select_appropriate_strategy(self, topic: str, constraints: List[str]) -> str:
        """S√©lectionne la strat√©gie de g√©n√©ration appropri√©e"""
        
        # Facteurs influen√ßant la s√©lection
        constraint_level = len(constraints) / 10.0
        domain_familiarity = self._assess_domain_familiarity(topic)
        creative_flow = (creative_states["creative_flow"] if isinstance(creative_states, dict) else getattr(creative_states, "creative_flow", None))
        
        # Logique de s√©lection
        if constraint_level > 0.7:
            return "constraint_challenge"
        elif domain_familiarity < 0.3:
            return "random_association"
        elif creative_flow > 0.7:
            return "domain_transfer"
        else:
            return "attribute_listing"
    
    def _random_association_strategy(self, topic: str, constraints: List[str], 
                                   num_ideas: int) -> List[str]:
        """Strat√©gie: associations al√©atoires"""
        ideas = []
        
        # Activation des concepts li√©s au topic
        related_concepts = self._get_related_concepts(topic, distance=2)
        
        for _ in range(num_ideas * 3):  # G√©n√©rer plus pour filtrer
            # S√©lection al√©atoire de concepts
            concept1 = random.choice(related_concepts) if related_concepts else topic
            concept2 = random.choice(list((conceptual_space["concept_network"] if isinstance(conceptual_space, dict) else getattr(conceptual_space, "concept_network", None)).nodes()))
            
            # Combinaison cr√©ative
            combined_idea = f"{concept1} + {concept2} = {self._combine_concepts(concept1, concept2)}"
            
            # V√©rification des contraintes
            if self._satisfies_constraints(combined_idea, constraints):
                ideas.append(combined_idea)
            
            if len(ideas) >= num_ideas:
                break
        
        return ideas[:num_ideas]
    
    def _domain_transfer_strategy(self, topic: str, constraints: List[str], 
                                num_ideas: int) -> List[str]:
        """Strat√©gie: transfert inter-domaines"""
        ideas = []
        
        # Identification de domaines sources
        source_domains = list((creative_knowledge["analogical_sources"] if isinstance(creative_knowledge, dict) else getattr(creative_knowledge, "analogical_sources", None)).keys())
        
        for _ in range(num_ideas):
            source_domain = random.choice(source_domains)
            domain_concepts = (creative_knowledge["analogical_sources"] if isinstance(creative_knowledge, dict) else getattr(creative_knowledge, "analogical_sources", None))[source_domain]
            source_concept = random.choice(domain_concepts)
            
            # Transfert analogique
            transferred_idea = f"Application de {source_concept} ({source_domain}) √† {topic}"
            
            if self._satisfies_constraints(transferred_idea, constraints):
                ideas.append(transferred_idea)
        
        return ideas
    
    def _constraint_challenge_strategy(self, topic: str, constraints: List[str], 
                                     num_ideas: int) -> List[str]:
        """Strat√©gie: d√©fi des contraintes"""
        ideas = []
        
        for constraint in constraints:
            # Inversion de contrainte
            challenged_constraint = self._challenge_constraint(constraint)
            
            # G√©n√©ration bas√©e sur la contrainte invers√©e
            idea = f"{topic} sans la limitation: {challenged_constraint}"
            ideas.append(idea)
            
            if len(ideas) >= num_ideas:
                break
        
        # Compl√©tion si n√©cessaire
        while len(ideas) < num_ideas:
            extra_idea = f"{topic} avec approche radicalement diff√©rente"
            ideas.append(extra_idea)
        
        return ideas[:num_ideas]
    
    def _attribute_listing_strategy(self, topic: str, constraints: List[str], 
                                  num_ideas: int) -> List[str]:
        """Strat√©gie: liste d'attributs"""
        ideas = []
        
        # Extraction d'attributs du topic
        attributes = self._extract_attributes(topic)
        
        # Modification syst√©matique des attributs
        for attribute in attributes[:min(5, len(attributes))]:
            modifications = ["amplifier", "r√©duire", "inverser", "combiner", "transformer"]
            
            for modification in modifications:
                idea = f"{topic} avec {attribute} {modification}"
                
                if self._satisfies_constraints(idea, constraints):
                    ideas.append(idea)
                
                if len(ideas) >= num_ideas:
                    break
            
            if len(ideas) >= num_ideas:
                break
        
        return ideas[:num_ideas]
    
    def _forced_relationship_strategy(self, topic: str, constraints: List[str], 
                                    num_ideas: int) -> List[str]:
        """Strat√©gie: relation forc√©e"""
        ideas = []
        
        # Concepts sans relation apparente
        unrelated_concepts = self._get_unrelated_concepts(topic, threshold=0.1)
        
        for concept in unrelated_concepts[:num_ideas]:
            # For√ßage de relation
            forced_idea = f"Relation forc√©e entre {topic} et {concept}: {self._force_relationship(topic, concept)}"
            
            if self._satisfies_constraints(forced_idea, constraints):
                ideas.append(forced_idea)
        
        return ideas
    
    def _get_related_concepts(self, concept: str, distance: int = 1) -> List[str]:
        """R√©cup√®re les concepts reli√©s dans le r√©seau"""
        concept_network = (conceptual_space["concept_network"] if isinstance(conceptual_space, dict) else getattr(conceptual_space, "concept_network", None))
        
        if concept not in concept_network:
            return []
        
        related = []
        for node in concept_network.nodes():
            if node != concept:
                try:
                    # Calcul du plus court chemin
                    path_length = nx.shortest_path_length(concept_network, concept, node)
                    if path_length <= distance:
                        related.append(node)
                except nx.NetworkXNoPath:
                    continue
        
        return related
    
    def _combine_concepts(self, concept1: str, concept2: str) -> str:
        """Combine deux concepts de mani√®re cr√©ative"""
        combination_patterns = [
            f"{concept1} utilisant {concept2}",
            f"{concept2} appliqu√© √† {concept1}",
            f"fusion de {concept1} et {concept2}",
            f"{concept1} inspir√© par {concept2}",
            f"{concept2} comme m√©taphore pour {concept1}"
        ]
        
        return random.choice(combination_patterns)
    
    def _satisfies_constraints(self, idea: str, constraints: List[str]) -> bool:
        """V√©rifie si une id√©e satisfait les contraintes"""
        if not constraints:
            return True
        
        idea_lower = idea.lower()
        for constraint in constraints:
            constraint_lower = constraint.lower()
            # V√©rification basique de violation de contrainte
            if "sans" in constraint_lower and "avec" in idea_lower:
                forbidden = constraint_lower.replace("sans", "").strip()
                if forbidden in idea_lower:
                    return False
            elif "avec" in constraint_lower and "sans" in idea_lower:
                required = constraint_lower.replace("avec", "").strip()
                if required not in idea_lower:
                    return False
        
        return True
    
    def _challenge_constraint(self, constraint: str) -> str:
        """D√©fie une contrainte de mani√®re cr√©ative"""
        if "sans" in constraint.lower():
            return constraint.lower().replace("sans", "avec exc√®s de")
        elif "avec" in constraint.lower():
            return constraint.lower().replace("avec", "sans")
        else:
            return f"inversion de: {constraint}"
    
    def _extract_attributes(self, concept: str) -> List[str]:
        """Extrait les attributs d'un concept"""
        # Attributs g√©n√©riques bas√©s sur le concept
        generic_attributes = {
            "taille", "couleur", "forme", "texture", "poids", "dur√©e", 
            "intensit√©", "complexit√©", "vitesse", "fr√©quence", "co√ªt"
        }
        
        # Filtrage bas√© sur la pertinence du concept
        concept_lower = concept.lower()
        relevant_attributes = []
        
        for attribute in generic_attributes:
            # V√©rification de pertinence basique
            if any(word in concept_lower for word in ["grand", "petit", "taille"]) and attribute == "taille":
                relevant_attributes.append(attribute)
            elif any(word in concept_lower for word in ["couleur", "color√©", "teinte"]) and attribute == "couleur":
                relevant_attributes.append(attribute)
            else:
                # Ajout al√©atoire avec probabilit√© r√©duite
                if random.random() < 0.3:
                    relevant_attributes.append(attribute)
        
        return relevant_attributes if relevant_attributes else list(generic_attributes)[:3]
    
    def _get_unrelated_concepts(self, concept: str, threshold: float = 0.1) -> List[str]:
        """R√©cup√®re les concepts non reli√©s"""
        concept_network = (conceptual_space["concept_network"] if isinstance(conceptual_space, dict) else getattr(conceptual_space, "concept_network", None))
        all_concepts = list(concept_network.nodes())
        unrelated = []
        
        for other_concept in all_concepts:
            if other_concept != concept:
                try:
                    # Calcul de la distance conceptuelle
                    if not nx.has_path(concept_network, concept, other_concept):
                        unrelated.append(other_concept)
                    else:
                        path_length = nx.shortest_path_length(concept_network, concept, other_concept)
                        if path_length > 3:  # Seuil de non-relation
                            unrelated.append(other_concept)
                except nx.NetworkXNoPath:
                    unrelated.append(other_concept)
        
        return unrelated[:20]  # Limiter le nombre
    
    def _force_relationship(self, concept1: str, concept2: str) -> str:
        """Force une relation entre deux concepts non reli√©s"""
        relationship_types = [
            "comme source d'inspiration",
            "comme contrainte cr√©ative",
            "comme √©l√©ment de contraste",
            "comme m√©taphore structurelle",
            "comme principe organisationnel"
        ]
        
        return random.choice(relationship_types)
    
    def _develop_raw_idea(self, raw_idea: str, topic: str, constraints: List[str]) -> CreativeIdea:
        """D√©veloppe une id√©e brute en id√©e cr√©ative structur√©e"""
        idea_id = f"idea_{int(time.time())}_{random.randint(1000, 9999)}"
        
        # Analyse de l'id√©e
        novelty = self._assess_novelty(raw_idea, topic)
        usefulness = self._assess_usefulness(raw_idea, topic)
        feasibility = self._assess_feasibility(raw_idea)
        elaboration = 0.3  # √âlaboration initiale basse
        
        # Extraction des composants
        components = self._extract_components(raw_idea)
        domains = self._identify_domains(raw_idea)
        associations = self._generate_associations(raw_idea)
        
        idea = CreativeIdea(
            id=idea_id,
            concept_core=raw_idea,
            description=f"Id√©e cr√©ative: {raw_idea}",
            state=IdeaState.RAW,
            novelty=novelty,
            usefulness=usefulness,
            feasibility=feasibility,
            elaboration=elaboration,
            domains=domains,
            components=components,
            associations=associations,
            created_time=time.time(),
            last_modified=time.time(),
            development_history=[{
                "timestamp": time.time(),
                "action": "cr√©ation",
                "state": "raw",
                "notes": "Id√©e g√©n√©r√©e initialement"
            }],
            emotional_affinity=self._assess_emotional_affinity(raw_idea),
            activation_level=0.1
        )
        
        return idea
    
    def _assess_novelty(self, idea: str, topic: str) -> float:
        """√âvalue la nouveaut√© d'une id√©e"""
        # Facteurs de nouveaut√©
        factors = []
        
        # Nouveaut√© lexicale
        idea_words = set(idea.lower().split())
        topic_words = set(topic.lower().split())
        lexical_overlap = len(idea_words & topic_words) / len(idea_words | topic_words) if idea_words | topic_words else 0
        lexical_novelty = 1.0 - lexical_overlap
        factors.append(lexical_novelty * 0.4)
        
        # Nouveaut√© conceptuelle (bas√©e sur le r√©seau)
        concept_novelty = self._assess_conceptual_novelty(idea)
        factors.append(concept_novelty * 0.6)
        
        return sum(factors) / len(factors) if factors else 0.5
    
    def _assess_conceptual_novelty(self, idea: str) -> float:
        """√âvalue la nouveaut√© conceptuelle"""
        concept_network = (conceptual_space["concept_network"] if isinstance(conceptual_space, dict) else getattr(conceptual_space, "concept_network", None))
        idea_concepts = self._extract_concepts_from_text(idea)
        
        if not idea_concepts:
            return 0.5
        
        # Distance moyenne entre les concepts de l'id√©e
        total_distance = 0
        concept_pairs = list(combinations(idea_concepts, 2))
        
        if not concept_pairs:
            return 0.5
        
        for concept1, concept2 in concept_pairs:
            if concept1 in concept_network and concept2 in concept_network:
                try:
                    distance = nx.shortest_path_length(concept_network, concept1, concept2)
                    total_distance += distance
                except nx.NetworkXNoPath:
                    total_distance += 5  # Distance maximale estim√©e
        
        avg_distance = total_distance / len(concept_pairs)
        novelty = min(avg_distance / 5.0, 1.0)  # Normalisation
        
        return novelty
    
    def _assess_usefulness(self, idea: str, topic: str) -> float:
        """√âvalue l'utilit√© d'une id√©e"""
        # Facteurs d'utilit√©
        factors = []
        
        # Pertinence au topic
        relevance = self._assess_relevance(idea, topic)
        factors.append(relevance * 0.4)
        
        # Potentiel d'application
        applicability = self._assess_applicability(idea)
        factors.append(applicability * 0.3)
        
        # Valeur pratique
        practical_value = self._assess_practical_value(idea)
        factors.append(practical_value * 0.3)
        
        return sum(factors) / len(factors) if factors else 0.5
    
    def _assess_relevance(self, idea: str, topic: str) -> float:
        """√âvalue la pertinence au topic"""
        idea_lower = idea.lower()
        topic_lower = topic.lower()
        
        # Chevauchement s√©mantique basique
        idea_words = set(idea_lower.split())
        topic_words = set(topic_lower.split())
        
        if not idea_words or not topic_words:
            return 0.3
        
        overlap = len(idea_words & topic_words)
        relevance = overlap / len(topic_words)
        
        return min(relevance, 1.0)
    
    def _assess_applicability(self, idea: str) -> float:
        """√âvalue l'applicabilit√© de l'id√©e"""
        # Indicateurs d'applicabilit√©
        applicability_indicators = ["solution", "application", "utiliser", "impl√©menter", "appliquer"]
        idea_lower = idea.lower()
        
        score = 0.3  # Score de base
        
        for indicator in applicability_indicators:
            if indicator in idea_lower:
                score += 0.1
        
        return min(score, 1.0)
    
    def _assess_practical_value(self, idea: str) -> float:
        """√âvalue la valeur pratique"""
        # Indicateurs de valeur pratique
        value_indicators = ["efficace", "efficient", "√©conomique", "simple", "robuste"]
        idea_lower = idea.lower()
        
        score = 0.3  # Score de base
        
        for indicator in value_indicators:
            if indicator in idea_lower:
                score += 0.1
        
        return min(score, 1.0)
    
    def _assess_feasibility(self, idea: str) -> float:
        """√âvalue la faisabilit√© de l'id√©e"""
        # Facteurs de faisabilit√©
        factors = []
        
        # Complexit√© per√ßue
        complexity = self._assess_complexity(idea)
        feasibility_from_complexity = 1.0 - complexity
        factors.append(feasibility_from_complexity * 0.4)
        
        # Ressources n√©cessaires
        resource_demand = self._assess_resource_demand(idea)
        feasibility_from_resources = 1.0 - resource_demand
        factors.append(feasibility_from_resources * 0.3)
        
        # Temps de r√©alisation
        time_requirement = self._assess_time_requirement(idea)
        feasibility_from_time = 1.0 - time_requirement
        factors.append(feasibility_from_time * 0.3)
        
        return sum(factors) / len(factors) if factors else 0.5
    
    def _assess_complexity(self, idea: str) -> float:
        """√âvalue la complexit√© de l'id√©e"""
        # M√©triques basiques de complexit√©
        word_count = len(idea.split())
        concept_count = len(self._extract_concepts_from_text(idea))
        
        complexity = (word_count * 0.01) + (concept_count * 0.05)
        return min(complexity, 1.0)
    
    def _assess_resource_demand(self, idea: str) -> float:
        """√âvalue la demande en ressources"""
        # Indicateurs de demande de ressources
        resource_indicators = ["co√ªteux", "complexe", "sp√©cialis√©", "rare", "avanc√©"]
        idea_lower = idea.lower()
        
        score = 0.3  # Score de base
        
        for indicator in resource_indicators:
            if indicator in idea_lower:
                score += 0.1
        
        return min(score, 1.0)
    
    def _assess_time_requirement(self, idea: str) -> float:
        """√âvalue le temps de r√©alisation requis"""
        # Indicateurs de temps
        time_indicators = ["long", "rapide", "imm√©diat", "progressif", "√©tapier"]
        idea_lower = idea.lower()
        
        score = 0.3  # Score de base
        
        for indicator in time_indicators:
            if "long" in indicator and indicator in idea_lower:
                score += 0.2
            elif "rapide" in indicator or "imm√©diat" in indicator:
                if indicator in idea_lower:
                    score -= 0.1
        
        return max(0.1, min(score, 1.0))
    
    def _extract_components(self, idea: str) -> List[str]:
        """Extrait les composants d'une id√©e"""
        # Extraction basique bas√©e sur la structure
        components = []
        
        # S√©paration par mots-cl√©s
        separators = ["+", "avec", "utilisant", "appliquant", "inspir√© par"]
        
        for separator in separators:
            if separator in idea:
                parts = idea.split(separator)
                components.extend([part.strip() for part in parts])
                break
        
        if not components:
            # Fallback: mots significatifs
            words = idea.split()
            components = [word for word in words if len(word) > 3][:3]
        
        return components
    
    def _identify_domains(self, idea: str) -> List[str]:
        """Identifie les domaines concern√©s par l'id√©e"""
        domains = []
        idea_lower = idea.lower()
        
        # Mapping mot-cl√© -> domaine
        domain_mapping = {
            "technologie": ["technologie", "digital", "informatique", "programmation"],
            "art": ["art", "cr√©atif", "design", "esth√©tique"],
            "science": ["science", "recherche", "exp√©rience", "d√©couverte"],
            "affaires": ["business", "commerce", "entreprise", "profit"],
            "√©ducation": ["√©ducation", "apprentissage", "enseignement", "savoir"]
        }
        
        for domain, keywords in domain_mapping.items():
            if any(keyword in idea_lower for keyword in keywords):
                domains.append(domain)
        
        return domains if domains else ["g√©n√©ral"]
    
    def _generate_associations(self, idea: str) -> List[str]:
        """G√©n√®re des associations pour l'id√©e"""
        concepts = self._extract_concepts_from_text(idea)
        associations = []
        
        for concept in concepts[:3]:  # Limiter le nombre
            related = self._get_related_concepts(concept, distance=1)
            if related:
                associations.extend(related[:2])  # 2 associations par concept
        
        return list(set(associations))[:5]  # Maximum 5 associations uniques
    
    def _extract_concepts_from_text(self, text: str) -> List[str]:
        """Extrait les concepts d'un texte"""
        concept_network = (conceptual_space["concept_network"] if isinstance(conceptual_space, dict) else getattr(conceptual_space, "concept_network", None))
        words = text.lower().split()
        
        # Filtrage des mots significatifs
        concepts = []
        for word in words:
            if len(word) > 3 and word in concept_network:
                concepts.append(word)
        
        return concepts
    
    def _assess_emotional_affinity(self, idea: str) -> float:
        """√âvalue l'affinit√© √©motionnelle avec l'id√©e"""
        if not self.emotional_system:
            return 0.5
        
        # Simulation de r√©action √©motionnelle √† l'id√©e
        emotional_response = self.emotional_system.process_stimulus(
            f"id√©e cr√©ative: {idea}", 
            {"context": "√©valuation_cr√©ative"}
        )
        
        # Affinit√© bas√©e sur la valence √©motionnelle
        affinity = (emotional_response.valence + 1.0) / 2.0  # Conversion -1,1 -> 0,1
        
        return affinity
    
    def _update_creative_metrics(self, ideas_generated: int, generation_time: float, strategy: str):
        """Met √† jour les m√©triques cr√©atives"""
        # Mise √† jour de l'√©tat de flux cr√©atif
        efficiency = ideas_generated / max(generation_time, 1.0)
        flow_increase = min(efficiency * 0.1, 0.2)
if isinstance(creative_states, dict):
    creative_states['creative_flow'] = min(
else:
    setattr(creative_states, 'creative_flow', min()
            1.0, (creative_states["creative_flow"] if isinstance(creative_states, dict) else getattr(creative_states, "creative_flow", None)) + flow_increase
        )
        
        # Mise √† jour de la confiance cr√©ative
        if ideas_generated > 0:
            confidence_increase = ideas_generated * 0.02
if isinstance(creative_states, dict):
    creative_states['creative_confidence'] = min(
else:
    setattr(creative_states, 'creative_confidence', min()
                1.0, (creative_states["creative_confidence"] if isinstance(creative_states, dict) else getattr(creative_states, "creative_confidence", None)) + confidence_increase
        )
        
        # Enregistrement d‚Äôapprentissage
        learning_record = {
            "timestamp": time.time(),
            "strategy": strategy,
            "ideas_generated": ideas_generated,
            "generation_time": generation_time,
            "efficiency": efficiency,
            "new_creative_state": self.creative_states.copy()
        }
if isinstance(creative_history, dict):
    creative_history['learning_trajectory'].append(learning_record)
else:
    getattr(creative_history, 'learning_trajectory', []).append(learning_record)
    
    def create_conceptual_blend(self, concept1: str, concept2: str) -> ConceptualBlend:
        """
        Cr√©e un m√©lange conceptuel entre deux concepts
        Bas√© sur la th√©orie des espaces mentaux de Fauconnier et Turner
        """
        start_time = time.time()
        
        # Pr√©paration des espaces d'entr√©e
        input_space1 = self._prepare_input_space(concept1)
        input_space2 = self._prepare_input_space(concept2)
        
        # Construction de l'espace g√©n√©rique
        generic_space = self._build_generic_space(input_space1, input_space2)
        
        # Projection s√©lective vers l'espace blend√©
        blended_space = self._create_blended_space(input_space1, input_space2, generic_space)
        
        # D√©tection de structure √©mergente
        emergent_structure = self._detect_emergent_structure(blended_space)
        
        # √âvaluation du blend
        creativity_score = self._evaluate_blend_creativity(blended_space, emergent_structure)
        coherence = self._evaluate_blend_coherence(blended_space)
        elaboration_potential = self._evaluate_elaboration_potential(blended_space)
        
        blend = ConceptualBlend(
            blend_id=f"blend_{int(time.time())}_{random.randint(1000, 9999)}",
            input_spaces=[concept1, concept2],
            generic_space=generic_space,
            blended_space=blended_space,
            emergent_structure=emergent_structure,
            creativity_score=creativity_score,
            coherence=coherence,
            elaboration_potential=elaboration_potential
        )
        
        # Enregistrement
if isinstance(conceptual_blending, dict):
    conceptual_blending['blend_history'].append(blend)
else:
    getattr(conceptual_blending, 'blend_history', []).append(blend)
if isinstance(creative_history, dict):
    creative_history['blends_created'].append(blend)
else:
    getattr(creative_history, 'blends_created', []).append(blend)
        
        return blend
    
    def _prepare_input_space(self, concept: str) -> Dict[str, Any]:
        """Pr√©pare un espace mental d'entr√©e pour un concept"""
        concept_network = (conceptual_space["concept_network"] if isinstance(conceptual_space, dict) else getattr(conceptual_space, "concept_network", None))
        
        # Structure de l'espace d'entr√©e
        input_space = {
            "core_concept": concept,
            "elements": [],
            "relations": [],
            "properties": [],
            "functions": []
        }
        
        if concept in concept_network:
            # √âl√©ments reli√©s
            neighbors = list(concept_network.neighbors(concept))
if isinstance(input_space, dict):
    input_space['elements'] = neighbors[:5]  # Limiter le nombre
else:
    setattr(input_space, 'elements', neighbors[:5])  # Limiter le nombre)
            
            # Propri√©t√©s bas√©es sur le r√©seau
            degree = concept_network.degree(concept)
if isinstance(input_space, dict):
    input_space['properties'].append(f"connectivit√©: {degree}")
else:
    getattr(input_space, 'properties', []).append(f"connectivit√©: {degree}")
            
            # Relations
            for neighbor in neighbors[:3]:
                edge_data = concept_network.get_edge_data(concept, neighbor)
                weight = edge_data.get('weight', 0.5) if edge_data else 0.5
if isinstance(input_space, dict):
    input_space['relations'].append(f"{concept} -> {neighbor} (force: {weight:.2f})")
else:
    getattr(input_space, 'relations', []).append(f"{concept} -> {neighbor} (force: {weight:.2f})")
        
        # Propri√©t√©s g√©n√©riques
        generic_properties = ["abstrait", "concret", "complexe", "simple", "dynamique", "statique"]
        (input_space["properties"] if isinstance(input_space, dict) else getattr(input_space, "properties", None)).extend(random.sample(generic_properties, 2))
        
        # Fonctions potentielles
        generic_functions = ["repr√©senter", "organiser", "transformer", "communiquer", "cr√©er"]
        (input_space["functions"] if isinstance(input_space, dict) else getattr(input_space, "functions", None)).extend(random.sample(generic_functions, 2))
        
        return input_space
    
    def _build_generic_space(self, space1: Dict[str, Any], space2: Dict[str, Any]) -> List[str]:
        """Construit l'espace g√©n√©rique commun"""
        generic_elements = []
        
        # √âl√©ments communs
        common_elements = set((space1["elements"] if isinstance(space1, dict) else getattr(space1, "elements", None))) & set((space2["elements"] if isinstance(space2, dict) else getattr(space2, "elements", None)))
        generic_elements.extend(list(common_elements)[:3])
        
        # Propri√©t√©s communes
        all_properties = (space1["properties"] if isinstance(space1, dict) else getattr(space1, "properties", None)) + (space2["properties"] if isinstance(space2, dict) else getattr(space2, "properties", None))
        property_counts = defaultdict(int)
        for prop in all_properties:
            property_counts[prop] += 1
        
        common_properties = [prop for prop, count in property_counts.items() if count > 1]
        generic_elements.extend(common_properties[:2])
        
        # √âl√©ments g√©n√©riques de secours
        if len(generic_elements) < 3:
            fallback_elements = ["relation", "structure", "processus", "√©l√©ment", "syst√®me"]
            needed = 3 - len(generic_elements)
            generic_elements.extend(random.sample(fallback_elements, needed))
        
        return generic_elements
    
    def _create_blended_space(self, space1: Dict[str, Any], space2: Dict[str, Any], 
                            generic_space: List[str]) -> str:
        """Cr√©e l'espace blend√© r√©sultant"""
        
        # Combinaison cr√©ative des concepts de base
        core_blend = f"{space1['core_concept']}-{space2['core_concept']} hybride"
        
        # Int√©gration d'√©l√©ments des deux espaces
        space1_elements = random.sample((space1["elements"] if isinstance(space1, dict) else getattr(space1, "elements", None)), min(2, len((space1["elements"] if isinstance(space1, dict) else getattr(space1, "elements", None)))))
        space2_elements = random.sample((space2["elements"] if isinstance(space2, dict) else getattr(space2, "elements", None)), min(2, len((space2["elements"] if isinstance(space2, dict) else getattr(space2, "elements", None)))))
        
        # Construction de la description
        description_parts = [
            core_blend,
            f"int√©grant {', '.join(space1_elements)} de {space1['core_concept']}",
            f"avec {', '.join(space2_elements)} de {space2['core_concept']}",
            f"via {random.choice(generic_space)}"
        ]
        
        return " ".join(description_parts)
    
    def _detect_emergent_structure(self, blended_space: str) -> List[str]:
        """D√©tecte la structure √©mergente dans l'espace blend√©"""
        emergent_structures = []
        
        # Patterns de structure √©mergente
        patterns = [
            "nouvelle propri√©t√© √©mergente",
            "comportement impr√©vu",
            "fonctionnalit√© √©mergente",
            "relation inattendue",
            "pattern structurel nouveau"
        ]
        
        # S√©lection bas√©e sur la complexit√© du blend
        words = blended_space.split()
        complexity = len(words) / 10.0
        
        num_structures = max(1, int(complexity * 3))
        selected_structures = random.sample(patterns, min(num_structures, len(patterns)))
        
        for structure in selected_structures:
            # Personnalisation bas√©e sur le contenu du blend
            customized_structure = f"{structure} dans {blended_space}"
            emergent_structures.append(customized_structure)
        
        return emergent_structures
    
    def _evaluate_blend_creativity(self, blended_space: str, emergent_structure: List[str]) -> float:
        """√âvalue la cr√©ativit√© du blend conceptuel"""
        factors = []
        
        # Originalit√© bas√©e sur la raret√© des combinaisons
        originality = len(blended_space) / 100.0  # M√©trique simplifi√©e
        factors.append(min(originality, 1.0) * 0.4)
        
        # Richesse de la structure √©mergente
        emergence_richness = len(emergent_structure) / 5.0
        factors.append(min(emergence_richness, 1.0) * 0.3)
        
        # Complexit√© int√©grative
        word_count = len(blended_space.split())
        complexity = min(word_count / 20.0, 1.0)
        factors.append(complexity * 0.3)
        
        return sum(factors) / len(factors) if factors else 0.5
    
    def _evaluate_blend_coherence(self, blended_space: str) -> float:
        """√âvalue la coh√©rence du blend conceptuel"""
        # Coh√©rence bas√©e sur la plausibilit√© s√©mantique
        words = blended_space.split()
        meaningful_ratio = sum(1 for word in words if len(word) > 3) / len(words) if words else 0
        
        # Coh√©rence structurelle basique
        structural_coherence = 0.7 if "hybride" in blended_space else 0.5
        
        return (meaningful_ratio + structural_coherence) / 2.0
    
    def _evaluate_elaboration_potential(self, blended_space: str) -> float:
        """√âvalue le potentiel d'√©laboration du blend"""
        # Potentiel bas√© sur la richesse conceptuelle
        concepts = self._extract_concepts_from_text(blended_space)
        concept_potential = min(len(concepts) / 5.0, 1.0)
        
        # Potentiel bas√© sur la complexit√©
        complexity = len(blended_space.split()) / 10.0
        complexity_potential = min(complexity, 1.0)
        
        return (concept_potential + complexity_potential) / 2.0
    
    def experience_insight(self, problem_context: Dict[str, Any]) -> Optional[CreativeInsight]:
        """
        Exp√©rience un insight cr√©atif (moment "Eur√™ka")
        """
        # V√©rification des conditions d'insight
        if not self._check_insight_conditions():
            return None
        
        # G√©n√©ration de l'insight
        insight_content = self._generate_insight_content(problem_context)
        if not insight_content:
            return None
        
        # Cr√©ation de l'objet insight
        insight = CreativeInsight(
            insight_id=f"insight_{int(time.time())}_{random.randint(1000, 9999)}",
            type=self._determine_insight_type(insight_content),
            content=insight_content,
            significance=self._assess_insight_significance(insight_content, problem_context),
            clarity=random.uniform(0.6, 0.9),
            surprise=random.uniform(0.7, 1.0),
            emotional_intensity=random.uniform(0.6, 0.9),
            preceding_incubation=self._get_incubation_duration(),
            trigger=self._identify_insight_trigger(),
            timestamp=time.time(),
            related_ideas=self._get_related_ideas(insight_content),
            verification_status="unverified"
        )
        
        # Enregistrement
if isinstance(insight_detection, dict):
    insight_detection['insight_history'].append(insight)
else:
    getattr(insight_detection, 'insight_history', []).append(insight)
if isinstance(creative_history, dict):
    creative_history['insights_experienced'].append(insight)
else:
    getattr(creative_history, 'insights_experienced', []).append(insight)
        
        # Mise √† jour de l'√©tat cr√©atif
        self._update_after_insight(insight)
        
        return insight
    
    def _check_insight_conditions(self) -> bool:
        """V√©rifie si les conditions sont favorables pour un insight"""
        conditions = []
        
        # √âtat de flux cr√©atif
        if (creative_states["creative_flow"] if isinstance(creative_states, dict) else getattr(creative_states, "creative_flow", None)) > 0.6:
            conditions.append(True)
        
        # Flexibilit√© cognitive
        if (creative_states["cognitive_flexibility"] if isinstance(creative_states, dict) else getattr(creative_states, "cognitive_flexibility", None)) > 0.5:
            conditions.append(True)
        
        # Niveau d'inspiration
        if (creative_states["inspiration_level"] if isinstance(creative_states, dict) else getattr(creative_states, "inspiration_level", None)) > 0.4:
            conditions.append(True)
        
        # Charge cognitive mod√©r√©e
        cognitive_load = self.contextual_influences.get("cognitive_load", 0.5)
        if 0.3 < cognitive_load < 0.7:
            conditions.append(True)
        
        return len(conditions) >= 3 and random.random() < 0.3  # Probabilit√© d'occurrence
    
    def _generate_insight_content(self, problem_context: Dict[str, Any]) -> Optional[str]:
        """G√©n√®re le contenu de l'insight"""
        problem_description = problem_context.get("problem", "probl√®me g√©n√©rique")
        
        # Patterns d'insight courants
        insight_patterns = [
            f"R√©alisation soudaine: {problem_description} peut √™tre abord√© compl√®tement diff√©remment",
            f"Connexion inattendue: {problem_description} est similaire √† {random.choice(list(self.creative_knowledge['analogical_sources'].keys()))}",
            f"Restructuration: {problem_description} n'est pas ce qu'il semble √™tre",
            f"Solution √©mergente: la r√©ponse √† {problem_description} √©tait l√† depuis le d√©but",
            f"Perspective nouvelle: {problem_description} vu sous un angle radicalement diff√©rent"
        ]
        
        return random.choice(insight_patterns) if random.random() < 0.7 else None
    
    def _determine_insight_type(self, insight_content: str) -> InsightType:
        """D√©termine le type d'insight"""
        content_lower = insight_content.lower()
        
        if "similaire" in content_lower or "comme" in content_lower:
            return InsightType.ANALOGICAL
        elif "diff√©remment" in content_lower or "angle" in content_lower:
            return InsightType.RESTRUCTURING
        elif "connexion" in content_lower or "lien" in content_lower:
            return InsightType.ASSOCIATIVE
        elif "√©mergent" in content_lower or "soudain" in content_lower:
            return InsightType.EMERGENT
        else:
            return InsightType.INTUITIVE
    
    def _assess_insight_significance(self, insight_content: str, problem_context: Dict[str, Any]) -> float:
        """√âvalue la signification de l'insight"""
        # Facteurs de signification
        factors = []
        
        # Longueur et complexit√©
        complexity = len(insight_content.split()) / 10.0
        factors.append(min(complexity, 1.0) * 0.3)
        
        # Originalit√© per√ßue
        originality = random.uniform(0.5, 0.9)
        factors.append(originality * 0.4)
        
        # Pertinence au probl√®me
        relevance = random.uniform(0.6, 1.0)
        factors.append(relevance * 0.3)
        
        return sum(factors) / len(factors)
    
    def _get_incubation_duration(self) -> float:
        """Estime la dur√©e d'incubation pr√©c√©dente"""
        # Bas√© sur l'historique r√©cent des id√©es
        recent_ideas = list((creative_history["ideas_generated"] if isinstance(creative_history, dict) else getattr(creative_history, "ideas_generated", None)))[-10:]
        if not recent_ideas:
            return random.uniform(10.0, 60.0)
        
        # Dur√©e moyenne depuis la derni√®re id√©e li√©e
        now = time.time()
        time_differences = [now - idea.created_time for idea in recent_ideas]
        avg_incubation = sum(time_differences) / len(time_differences)
        
        return min(avg_incubation, 3600.0)  # Maximum 1 heure
    
    def _identify_insight_trigger(self) -> str:
        """Identifie le d√©clencheur de l'insight"""
        triggers = [
            "changement de perspective",
            "association distante",
            "relaxation apr√®s effort intense",
            "stimulus environnemental",
            "conversation interne",
            "r√™verie √©veill√©e"
        ]
        
        return random.choice(triggers)
    
    def _get_related_ideas(self, insight_content: str) -> List[str]:
        """R√©cup√®re les id√©es reli√©es √† l'insight"""
        recent_ideas = list((creative_history["ideas_generated"] if isinstance(creative_history, dict) else getattr(creative_history, "ideas_generated", None)))[-5:]
        related = []
        
        for idea in recent_ideas:
            # V√©rification de similarit√© basique
            if any(word in insight_content.lower() for word in idea.concept_core.lower().split()[:3]):
                related.append(idea.id)
            
            if len(related) >= 2:
                break
        
        return related
    
    def _update_after_insight(self, insight: CreativeInsight):
        """Met √† jour l'√©tat apr√®s un insight"""
        # Boost de confiance cr√©ative
        confidence_boost = insight.significance * 0.2
if isinstance(creative_states, dict):
    creative_states['creative_confidence'] = min(
else:
    setattr(creative_states, 'creative_confidence', min()
            1.0, (creative_states["creative_confidence"] if isinstance(creative_states, dict) else getattr(creative_states, "creative_confidence", None)) + confidence_boost
        )
        
        # Augmentation de l'inspiration
        inspiration_boost = insight.emotional_intensity * 0.15
if isinstance(creative_states, dict):
    creative_states['inspiration_level'] = min(
else:
    setattr(creative_states, 'inspiration_level', min()
            1.0, (creative_states["inspiration_level"] if isinstance(creative_states, dict) else getattr(creative_states, "inspiration_level", None)) + inspiration_boost
        )
    
    def develop_innovation_project(self, core_idea: str, objectives: List[str], 
                                 constraints: List[str]) -> InnovationProject:
        """
        D√©veloppe un projet d'innovation structur√©
        """
        project_id = f"project_{int(time.time())}_{random.randint(1000, 9999)}"
        
        # Planification du d√©veloppement
        development_phases = self._plan_development_phases(core_idea, objectives)
        
        # √âvaluation des risques
        risk_assessment = self._assess_innovation_risks(core_idea, constraints)
        
        # D√©finition des m√©triques de succ√®s
        success_metrics = self._define_success_metrics(objectives)
        
        # Estimation des ressources
        resources_needed = self._estimate_resources_needed(core_idea, development_phases)
        
        project = InnovationProject(
            project_id=project_id,
            core_idea=core_idea,
            objectives=objectives,
            constraints=constraints,
            resources_needed=resources_needed,
            development_phases=development_phases,
            current_phase=0,
            success_metrics=success_metrics,
            risk_assessment=risk_assessment,
            team_dynamics={"auto_collaboration": True, "roles": ["g√©n√©rateur", "√©valuateur", "d√©veloppeur"]}
        )
        
        # Ajout au pipeline d'innovation
if isinstance(innovation_engine, dict):
    innovation_engine['innovation_pipeline'].append(project)
else:
    getattr(innovation_engine, 'innovation_pipeline', []).append(project)
if isinstance(creative_history, dict):
    creative_history['projects_completed'].append(project)
else:
    getattr(creative_history, 'projects_completed', []).append(project)
        
        return project
    
    def _plan_development_phases(self, core_idea: str, objectives: List[str]) -> List[Dict[str, Any]]:
        """Planifie les phases de d√©veloppement"""
        phases = []
        
        # Phases standard de d√©veloppement cr√©atif
        standard_phases = [
            {
                "name": "exploration_conceptuelle",
                "description": "Exploration approfondie du concept de base",
                "duration_estimate": random.uniform(5.0, 15.0),
                "resources": ["recherche", "brainstorming", "analyse comparative"]
            },
            {
                "name": "d√©veloppement_prototype",
                "description": "D√©veloppement d'une premi√®re version tangible",
                "duration_estimate": random.uniform(10.0, 30.0),
                "resources": ["conception", "test", "it√©ration"]
            },
            {
                "name": "validation_test",
                "description": "Test et validation de la solution",
                "duration_estimate": random.uniform(8.0, 20.0),
                "resources": ["exp√©rimentation", "feedback", "am√©lioration"]
            },
            {
                "name": "impl√©mentation_finale",
                "description": "Impl√©mentation de la solution finale",
                "duration_estimate": random.uniform(15.0, 40.0),
                "resources": ["d√©ploiement", "documentation", "formation"]
            }
        ]
        
        # Ajustement bas√© sur la complexit√© de l'id√©e
        complexity = len(core_idea.split()) / 10.0
        for phase in standard_phases:
            adjusted_phase = phase.copy()
            (adjusted_phase["duration_estimate"] if isinstance(adjusted_phase, dict) else getattr(adjusted_phase, "duration_estimate", None)) *= (1 + complexity)
            phases.append(adjusted_phase)
        
        return phases
    
    def _assess_innovation_risks(self, core_idea: str, constraints: List[str]) -> Dict[str, float]:
        """√âvalue les risques d'innovation"""
        risks = {}
        
        # Risque technique
        technical_risk = random.uniform(0.3, 0.8)
if isinstance(risks, dict):
    risks['technique'] = technical_risk
else:
    setattr(risks, 'technique', technical_risk)
        
        # Risque de march√© (simul√©)
        market_risk = random.uniform(0.2, 0.7)
if isinstance(risks, dict):
    risks['march√©'] = market_risk
else:
    setattr(risks, 'march√©', market_risk)
        
        # Risque de ressources
        resource_risk = len(constraints) / 10.0
if isinstance(risks, dict):
    risks['ressources'] = min(resource_risk, 1.0)
else:
    setattr(risks, 'ressources', min(resource_risk, 1.0))
        
        # Risque temporel
        time_risk = random.uniform(0.4, 0.9)
if isinstance(risks, dict):
    risks['temporel'] = time_risk
else:
    setattr(risks, 'temporel', time_risk)
        
        return risks
    
    def _define_success_metrics(self, objectives: List[str]) -> Dict[str, float]:
        """D√©finit les m√©triques de succ√®s"""
        metrics = {}
        
        for objective in objectives[:3]:  # Maximum 3 m√©triques
            metric_name = f"succ√®s_{objective.lower().replace(' ', '_')}"
            metrics[metric_name] = random.uniform(0.7, 0.95)
        
        # M√©triques standard
        standard_metrics = {
            "satisfaction_utilisateur": random.uniform(0.6, 0.9),
            "impact_innovation": random.uniform(0.5, 0.8),
            "efficacit√©_impl√©mentation": random.uniform(0.7, 0.9)
        }
        metrics.update(standard_metrics)
        
        return metrics
    
    def _estimate_resources_needed(self, core_idea: str, development_phases: List[Dict[str, Any]]) -> List[str]:
        """Estime les ressources n√©cessaires"""
        resources = []
        
        # Ressources bas√©es sur la complexit√©
        complexity = len(core_idea.split()) / 10.0
        
        base_resources = ["temps", "attention", "√©nergie_cognitive"]
        resources.extend(base_resources)
        
        if complexity > 0.5:
            resources.extend(["recherche_approfondie", "expertise_sp√©cialis√©e"])
        
        if complexity > 0.7:
            resources.extend(["exp√©rimentation", "it√©ration_multiple"])
        
        # Ressources des phases
        for phase in development_phases:
            resources.extend((phase["resources"] if isinstance(phase, dict) else getattr(phase, "resources", None)))
        
        return list(set(resources))  # √âliminer les doublons
    
    def _monitor_creative_state(self):
        """Surveille l'√©tat cr√©atif global"""
        # Mise √† jour bas√©e sur l'activit√© r√©cente
        recent_ideas = list((creative_history["ideas_generated"] if isinstance(creative_history, dict) else getattr(creative_history, "ideas_generated", None)))[-10:]
        recent_insights = list((creative_history["insights_experienced"] if isinstance(creative_history, dict) else getattr(creative_history, "insights_experienced", None)))[-5:]
        
        # Flux cr√©atif bas√© sur la productivit√©
        if recent_ideas:
            productivity = len(recent_ideas) / 10.0
            flow_change = (productivity - 0.5) * 0.1
if isinstance(creative_states, dict):
    creative_states['creative_flow'] = max(0.1, min(1.0, 
else:
    setattr(creative_states, 'creative_flow', max(0.1, min(1.0, )
                (creative_states["creative_flow"] if isinstance(creative_states, dict) else getattr(creative_states, "creative_flow", None)) + flow_change))
        
        # Flexibilit√© cognitive bas√©e sur la vari√©t√© des id√©es
        if len(recent_ideas) >= 3:
            domains_used = set()
            for idea in recent_ideas:
                domains_used.update(idea.domains)
            flexibility = len(domains_used) / 5.0
if isinstance(creative_states, dict):
    creative_states['cognitive_flexibility'] = max(0.1, min(1.0,
else:
    setattr(creative_states, 'cognitive_flexibility', max(0.1, min(1.0,)
                (creative_states["cognitive_flexibility"] if isinstance(creative_states, dict) else getattr(creative_states, "cognitive_flexibility", None)) * 0.9 + flexibility * 0.1))
        
        # Inspiration bas√©e sur les insights r√©cents
        if recent_insights:
            inspiration_boost = len(recent_insights) * 0.05
if isinstance(creative_states, dict):
    creative_states['inspiration_level'] = min(1.0,
else:
    setattr(creative_states, 'inspiration_level', min(1.0,)
                (creative_states["inspiration_level"] if isinstance(creative_states, dict) else getattr(creative_states, "inspiration_level", None)) + inspiration_boost)
    
    def _update_conceptual_space(self):
        """Met √† jour l'espace conceptuel dynamique"""
        concept_network = (conceptual_space["concept_network"] if isinstance(conceptual_space, dict) else getattr(conceptual_space, "concept_network", None))
        
        # D√©croissance naturelle de l'activation
        for node in concept_network.nodes():
            current_activation = concept_network.nodes[node].get("activation", 0.1)
            new_activation = current_activation * 0.99  # D√©croissance l√©g√®re
            concept_network.nodes[node]["activation"] = max(0.01, new_activation)
    
    def _evaluate_ongoing_ideas(self):
        """√âvalue les id√©es en cours de d√©veloppement"""
        recent_ideas = list((idea_generation["idea_pool"] if isinstance(idea_generation, dict) else getattr(idea_generation, "idea_pool", None)))[-20:]
        
        for idea in recent_ideas:
            if idea.state == IdeaState.RAW and random.random() < 0.1:
                # Promotion occasionnelle d'id√©es brutes
                idea.state = IdeaState.DEVELOPED
                idea.last_modified = time.time()
                idea.development_history.append({
                    "timestamp": time.time(),
                    "action": "promotion_automatique",
                    "state": "developed",
                    "notes": "Promotion bas√©e sur le potentiel d√©tect√©"
                })
    
    def _detect_creative_opportunities(self):
        """D√©tecte les opportunit√©s cr√©atives √©mergentes"""
        # Surveillance des patterns dans l'espace conceptuel
        concept_network = (conceptual_space["concept_network"] if isinstance(conceptual_space, dict) else getattr(conceptual_space, "concept_network", None))
        
        # D√©tection de concepts sous-utilis√©s
        for node in concept_network.nodes():
            activation = concept_network.nodes[node].get("activation", 0.1)
            if activation < 0.05:  # Concept tr√®s peu activ√©
                # Opportunit√© d'exploration
                if random.random() < 0.05:
                    self._create_exploration_opportunity(node)
    
    def _create_exploration_opportunity(self, concept: str):
        """Cr√©e une opportunit√© d'exploration pour un concept sous-utilis√©"""
        opportunity = {
            "type": "exploration_conceptuelle",
            "concept": concept,
            "potential": random.uniform(0.6, 0.9),
            "timestamp": time.time(),
            "action": f"Explorer le concept '{concept}' dans de nouveaux contextes"
        }
        
        # Pourrait d√©clencher une g√©n√©ration d'id√©es automatique
    
    def _process_incubation_phase(self):
        """Traite la phase d'incubation des id√©es"""
        # Augmentation de l'activation des id√©es en incubation
        for idea in (idea_generation["idea_pool"] if isinstance(idea_generation, dict) else getattr(idea_generation, "idea_pool", None)):
            if idea.state in [IdeaState.RAW, IdeaState.DEVELOPED]:
                # L√©g√®re augmentation de l'activation pendant l'incubation
                incubation_boost = random.uniform(0.01, 0.05)
                idea.activation_level = min(1.0, idea.activation_level + incubation_boost)
    
    def _monitor_insight_conditions(self):
        """Surveille les conditions favorables aux insights"""
        # V√©rification p√©riodique des conditions d'insight
        if self._check_insight_conditions() and random.random() < 0.1:
            # G√©n√©ration d'un insight opportuniste
            problem_context = {"problem": "optimisation_processus_cr√©atif"}
            self.experience_insight(problem_context)
    
    def get_creative_status(self) -> Dict[str, Any]:
        """Retourne le statut cr√©atif complet"""
        recent_ideas = list((idea_generation["idea_pool"] if isinstance(idea_generation, dict) else getattr(idea_generation, "idea_pool", None)))[-10:]
        
        return {
            "creative_states": self.creative_states.copy(),
            "current_phase": (creative_processes["current_phase"] if isinstance(creative_processes, dict) else getattr(creative_processes, "current_phase", None)),
            "recent_activity": {
                "ideas_generated": len(recent_ideas),
                "ideas_by_state": {
                    state.value: sum(1 for idea in recent_ideas if idea.state == state)
                    for state in IdeaState
                },
                "average_novelty": np.mean([idea.novelty for idea in recent_ideas]) if recent_ideas else 0.0,
                "average_usefulness": np.mean([idea.usefulness for idea in recent_ideas]) if recent_ideas else 0.0
            },
            "conceptual_space": {
                "concepts_count": (conceptual_space["concept_network"] if isinstance(conceptual_space, dict) else getattr(conceptual_space, "concept_network", None)).number_of_nodes(),
                "connections_count": (conceptual_space["concept_network"] if isinstance(conceptual_space, dict) else getattr(conceptual_space, "concept_network", None)).number_of_edges(),
                "average_activation": np.mean([
                    data.get("activation", 0.1) 
                    for _, data in (conceptual_space["concept_network"] if isinstance(conceptual_space, dict) else getattr(conceptual_space, "concept_network", None)).nodes(data=True)
                ]) if (conceptual_space["concept_network"] if isinstance(conceptual_space, dict) else getattr(conceptual_space, "concept_network", None)).nodes() else 0.0
            },
            "innovation_pipeline": {
                "projects_count": len((innovation_engine["innovation_pipeline"] if isinstance(innovation_engine, dict) else getattr(innovation_engine, "innovation_pipeline", None))),
                "active_projects": sum(1 for p in (innovation_engine["innovation_pipeline"] if isinstance(innovation_engine, dict) else getattr(innovation_engine, "innovation_pipeline", None)) 
                                     if p.current_phase < len(p.development_phases))
            },
            "historical_metrics": {
                "total_ideas": len((creative_history["ideas_generated"] if isinstance(creative_history, dict) else getattr(creative_history, "ideas_generated", None))),
                "total_blends": len((creative_history["blends_created"] if isinstance(creative_history, dict) else getattr(creative_history, "blends_created", None))),
                "total_insights": len((creative_history["insights_experienced"] if isinstance(creative_history, dict) else getattr(creative_history, "insights_experienced", None))),
                "total_projects": len((creative_history["projects_completed"] if isinstance(creative_history, dict) else getattr(creative_history, "projects_completed", None))),
                "breakthroughs": len((creative_history["creative_breakthroughs"] if isinstance(creative_history, dict) else getattr(creative_history, "creative_breakthroughs", None)))
            }
        }
    
    def stop_creativity_system(self):
        """Arr√™te le syst√®me de cr√©ativit√©"""
        self.running = False
        print("‚èπÔ∏è Syst√®me de cr√©ativit√© arr√™t√©")

# ===== SOUS-SYST√àMES SP√âCIALIS√âS =====

class ActivationSpreadingSystem:
    """Syst√®me de propagation d'activation dans l'espace conceptuel"""
    
    def __init__(self):
        self.propagation_factor = 0.3
        self.decay_rate = 0.1
    
    def spread_activation(self, network, start_node, activation_amount):
        """Propage l'activation √† partir d'un n≈ìud"""
        if start_node not in network:
            return
        
        visited = set()
        queue = deque([(start_node, activation_amount)])
        
        while queue:
            node, current_activation = queue.popleft()
            
            if node in visited or current_activation < 0.01:
                continue
            
            visited.add(node)
            
            # Mise √† jour de l'activation du n≈ìud
            current_node_activation = network.nodes[node].get("activation", 0.1)
            new_activation = current_node_activation + current_activation
            network.nodes[node]["activation"] = min(new_activation, 1.0)
            
            # Propagation aux voisins
            for neighbor in network.neighbors(node):
                edge_weight = network.edges[node, neighbor].get("weight", 0.5)
                neighbor_activation = current_activation * self.propagation_factor * edge_weight
                queue.append((neighbor, neighbor_activation))

class ConstraintRelaxationSystem:
    """Syst√®me de relaxation des contraintes pour la cr√©ativit√©"""
    
    def __init__(self):
        self.constraint_levels = defaultdict(float)
        self.relaxation_strategies = [
            "ignore_temporarily",
            "redefine_scope",
            "find_alternative",
            "challenge_assumption"
        ]
    
    def relax_constraints(self, constraints: List[str], creativity_need: float) -> List[str]:
        """Relaxe les contraintes selon le besoin de cr√©ativit√©"""
        if creativity_need < 0.5:
            return constraints  # Pas de relaxation n√©cessaire
        
        relaxed_constraints = []
        relaxation_rate = creativity_need - 0.5  # 0.0 √† 0.5
        
        for constraint in constraints:
            if random.random() < relaxation_rate:
                # Application d'une strat√©gie de relaxation
                strategy = random.choice(self.relaxation_strategies)
                relaxed_constraint = f"{constraint} [{strategy}]"
                relaxed_constraints.append(relaxed_constraint)
            else:
                relaxed_constraints.append(constraint)
        
        return relaxed_constraints

class DivergentThinker:
    """Penseur divergent - g√©n√©ration de nombreuses id√©es vari√©es"""
    
    def __init__(self):
        self.fluency = 0.7       # Nombre d'id√©es g√©n√©r√©es
        self.flexibility = 0.6    # Vari√©t√© des cat√©gories
        self.originality = 0.5    # Originalit√© des id√©es
        self.elaboration = 0.4    # D√©veloppement des id√©es
    
    def generate_divergent_ideas(self, topic: str, num_ideas: int) -> List[str]:
        """G√©n√®re des id√©es divergentes"""
        ideas = []
        
        for _ in range(num_ideas * 2):  # G√©n√©rer plus pour s√©lection
            idea = self._apply_divergent_strategy(topic)
            if idea not in ideas:
                ideas.append(idea)
            
            if len(ideas) >= num_ideas:
                break
        
        return ideas
    
    def _apply_divergent_strategy(self, topic: str) -> str:
        """Applique une strat√©gie de pens√©e divergente"""
        strategies = [
            self._attribute_modification,
            self._perspective_shift,
            self._analogical_transfer,
            self._constraint_removal
        ]
        
        strategy = random.choice(strategies)
        return strategy(topic)
    
    def _attribute_modification(self, topic: str) -> str:
        """Modifie les attributs du topic"""
        attributes = ["taille", "couleur", "forme", "fonction", "mat√©riau"]
        attribute = random.choice(attributes)
        modifications = ["augmenter", "r√©duire", "inverser", "combiner"]
        modification = random.choice(modifications)
        
        return f"{topic} avec {attribute} {modification}"
    
    def _perspective_shift(self, topic: str) -> str:
        """Change de perspective sur le topic"""
        perspectives = ["enfant", "expert", "√©tranger", "artiste", "scientifique"]
        perspective = random.choice(perspectives)
        
        return f"{topic} vu par un {perspective}"
    
    def _analogical_transfer(self, topic: str) -> str:
        """Transfert analogique depuis d'autres domaines"""
        domains = ["nature", "sport", "musique", "cuisine", "architecture"]
        domain = random.choice(domains)
        
        return f"{topic} comme en {domain}"
    
    def _constraint_removal(self, topic: str) -> str:
        """Supprime les contraintes habituelles"""
        constraints = ["co√ªt", "temps", "technologie", "ressources"]
        constraint = random.choice(constraints)
        
        return f"{topic} sans limitation de {constraint}"

class ConvergentThinker:
    """Penseur convergent - √©valuation et s√©lection des meilleures id√©es"""
    
    def __init__(self):
        self.analysis_depth = 0.7
        self.decision_quality = 0.6
        self.efficiency = 0.8
    
    def select_best_ideas(self, ideas: List[CreativeIdea], 
                         criteria: Dict[str, float], 
                         num_select: int) -> List[CreativeIdea]:
        """S√©lectionne les meilleures id√©es selon des crit√®res"""
        if not ideas:
            return []
        
        # Calcul des scores pour chaque id√©e
        scored_ideas = []
        for idea in ideas:
            score = self._calculate_idea_score(idea, criteria)
            scored_ideas.append((idea, score))
        
        # Tri par score d√©croissant
        scored_ideas.sort(key=lambda x: x[1], reverse=True)
        
        # S√©lection des meilleures
        selected = [idea for idea, score in scored_ideas[:num_select]]
        
        return selected
    
    def _calculate_idea_score(self, idea: CreativeIdea, criteria: Dict[str, float]) -> float:
        """Calcule un score global pour une id√©e"""
        score_components = []
        
        # Composantes de base
        if "novelty" in criteria:
            score_components.append(idea.novelty * (criteria["novelty"] if isinstance(criteria, dict) else getattr(criteria, "novelty", None)))
        
        if "usefulness" in criteria:
            score_components.append(idea.usefulness * (criteria["usefulness"] if isinstance(criteria, dict) else getattr(criteria, "usefulness", None)))
        
        if "feasibility" in criteria:
            score_components.append(idea.feasibility * (criteria["feasibility"] if isinstance(criteria, dict) else getattr(criteria, "feasibility", None)))
        
        if "elaboration" in criteria:
            score_components.append(idea.elaboration * (criteria["elaboration"] if isinstance(criteria, dict) else getattr(criteria, "elaboration", None)))
        
        # Score √©motionnel si disponible
        if "emotional_affinity" in criteria and hasattr(idea, 'emotional_affinity'):
            score_components.append(idea.emotional_affinity * (criteria["emotional_affinity"] if isinstance(criteria, dict) else getattr(criteria, "emotional_affinity", None)))
        
        return sum(score_components) / len(score_components) if score_components else 0.0

class LateralThinker:
    """Penseur lat√©ral - approches non conventionnelles"""
    
    def __init__(self):
        self.provocativeness = 0.6
        self.insight_potential = 0.5
        self.transformation_power = 0.4
    
    def generate_lateral_ideas(self, topic: str, num_ideas: int) -> List[str]:
        """G√©n√®re des id√©es par pens√©e lat√©rale"""
        ideas = []
        
        techniques = [
            self._random_entry,
            self._provocation,
            self._reversal,
            self._distortion
        ]
        
        for _ in range(num_ideas):
            technique = random.choice(techniques)
            idea = technique(topic)
            ideas.append(idea)
        
        return ideas
    
    def _random_entry(self, topic: str) -> str:
        """Point d'entr√©e al√©atoire"""
        random_words = ["chaise", "nuage", "rivi√®re", "horloge", "cristal"]
        entry_point = random.choice(random_words)
        
        return f"{topic} √† travers le concept de {entry_point}"
    
    def _provocation(self, topic: str) -> str:
        """Provocation cr√©ative"""
        provocations = [
            f"Et si {topic} √©tait impossible?",
            f"Et si {topic} fonctionnait √† l'envers?",
            f"Et si {topic} √©tait vivant?",
            f"Et si {topic} n'avait aucune limite?"
        ]
        
        return random.choice(provocations)
    
    def _reversal(self, topic: str) -> str:
        """Inversion des assumptions"""
        return f"Le contraire de {topic}"
    
    def _distortion(self, topic: str) -> str:
        """Distortion des param√®tres"""
        distortions = ["extr√™mement lent", "incroyablement grand", "absolument transparent"]
        distortion = random.choice(distortions)
        
        return f"{topic} mais {distortion}"

class IdeaQualityMetrics:
    """M√©triques de qualit√© des id√©es cr√©atives"""
    
    def __init__(self):
        self.quality_dimensions = {
            "novelty": 0.0,
            "resolution": 0.0,
            "elaboration": 0.0,
            "synthesis": 0.0
        }
    
    def assess_idea_quality(self, idea: CreativeIdea) -> Dict[str, float]:
        """√âvalue la qualit√© multidimensionnelle d'une id√©e"""
        metrics = {}
        
        # Nouveaut√©
if isinstance(metrics, dict):
    metrics['novelty'] = idea.novelty
else:
    setattr(metrics, 'novelty', idea.novelty)
        
        # R√©solution (utilit√© + faisabilit√©)
if isinstance(metrics, dict):
    metrics['resolution'] = (idea.usefulness + idea.feasibility) / 2.0
else:
    setattr(metrics, 'resolution', (idea.usefulness + idea.feasibility) / 2.0)
        
        # √âlaboration et synth√®se (estim√©es)
if isinstance(metrics, dict):
    metrics['elaboration'] = idea.elaboration
else:
    setattr(metrics, 'elaboration', idea.elaboration)
if isinstance(metrics, dict):
    metrics['synthesis'] = min(idea.novelty + idea.usefulness, 1.0)
else:
    setattr(metrics, 'synthesis', min(idea.novelty + idea.usefulness, 1.0))
        
        # Score global
if isinstance(metrics, dict):
    metrics['overall'] = sum(metrics.values()) / len(metrics)
else:
    setattr(metrics, 'overall', sum(metrics.values()) / len(metrics))
        
        return metrics

class ConceptualBlendingEngine:
    """Moteur de m√©lange conceptuel"""
    
    def __init__(self):
        self.blending_rules = [
            "composition",
            "completion",
            "elaboration"
        ]
    
    def create_blend(self, space1: Dict, space2: Dict) -> Dict[str, Any]:
        """Cr√©e un m√©lange conceptuel"""
        blend = {
            "elements": [],
            "relations": [],
            "properties": [],
            "emergent_structure": []
        }
        
        # Composition d'√©l√©ments
if isinstance(blend, dict):
    blend['elements'] = self._compose_elements((space1["elements"] if isinstance(space1, dict) else getattr(space1, "elements", None)), (space2["elements"] if isinstance(space2, dict) else getattr(space2, "elements", None)))
else:
    setattr(blend, 'elements', self._compose_elements((space1["elements"] if isinstance(space1, dict) else getattr(space1, "elements", None)), (space2["elements"] if isinstance(space2, dict) else getattr(space2, "elements", None))))
        
        # Completion des relations
if isinstance(blend, dict):
    blend['relations'] = self._complete_relations((space1["relations"] if isinstance(space1, dict) else getattr(space1, "relations", None)), (space2["relations"] if isinstance(space2, dict) else getattr(space2, "relations", None)))
else:
    setattr(blend, 'relations', self._complete_relations((space1["relations"] if isinstance(space1, dict) else getattr(space1, "relations", None)), (space2["relations"] if isinstance(space2, dict) else getattr(space2, "relations", None))))
        
        # √âlaboration des propri√©t√©s
if isinstance(blend, dict):
    blend['properties'] = self._elaborate_properties((space1["properties"] if isinstance(space1, dict) else getattr(space1, "properties", None)), (space2["properties"] if isinstance(space2, dict) else getattr(space2, "properties", None)))
else:
    setattr(blend, 'properties', self._elaborate_properties((space1["properties"] if isinstance(space1, dict) else getattr(space1, "properties", None)), (space2["properties"] if isinstance(space2, dict) else getattr(space2, "properties", None))))
        
        # D√©tection de structure √©mergente
if isinstance(blend, dict):
    blend['emergent_structure'] = self._detect_emergent_structure(blend)
else:
    setattr(blend, 'emergent_structure', self._detect_emergent_structure(blend))
        
        return blend
    
    def _compose_elements(self, elements1: List, elements2: List) -> List:
        """Compose les √©l√©ments des espaces d'entr√©e"""
        composed = []
        
        # √âl√©ments de base
        composed.extend(elements1[:2])
        composed.extend(elements2[:2])
        
        # Combinaisons cr√©atives
        if elements1 and elements2:
            for e1 in elements1[:1]:
                for e2 in elements2[:1]:
                    combined = f"{e1}-{e2}"
                    composed.append(combined)
        
        return list(set(composed))  # √âliminer les doublons
    
    def _complete_relations(self, relations1: List, relations2: List) -> List:
        """Complete les relations entre √©l√©ments"""
        completed = []
        
        completed.extend(relations1[:2])
        completed.extend(relations2[:2])
        
        # Relations crois√©es
        if relations1 and relations2:
            cross_relation = f"relation_crois√©e:{relations1[0]}_{relations2[0]}"
            completed.append(cross_relation)
        
        return completed
    
    def _elaborate_properties(self, props1: List, props2: List) -> List:
        """√âlabore les propri√©t√©s du blend"""
        elaborated = []
        
        elaborated.extend(props1[:2])
        elaborated.extend(props2[:2])
        
        # Propri√©t√©s √©mergentes
        emergent_props = ["nouvelle_fonctionnalit√©", "comportement_impr√©vu", "qualit√©_√©mergente"]
        elaborated.extend(random.sample(emergent_props, 1))
        
        return elaborated
    
    def _detect_emergent_structure(self, blend: Dict) -> List[str]:
        """D√©tecte la structure √©mergente"""
        emergent = []
        
        # Structures √©mergentes bas√©es sur la complexit√©
        element_count = len((blend["elements"] if isinstance(blend, dict) else getattr(blend, "elements", None)))
        relation_count = len((blend["relations"] if isinstance(blend, dict) else getattr(blend, "relations", None)))
        
        if element_count >= 3 and relation_count >= 2:
            emergent.append("structure_hi√©rarchique_√©mergente")
        
        if element_count >= 4:
            emergent.append("pattern_organisationnel_nouveau")
        
        return emergent

class CrossDomainMapper:
    """Syst√®me de mapping inter-domaines"""
    
    def __init__(self):
        self.domain_knowledge = {}
        self.mapping_strategies = ["structure", "function", "process"]
    
    def map_across_domains(self, source_domain: str, target_domain: str) -> List[str]:
        """√âtablit des mappings entre domaines"""
        mappings = []
        
        for strategy in self.mapping_strategies:
        if isinstance(strategy, str):
            try:
                strategy = {"raw_text": strategy}
            except Exception:
                print(f"[‚ö†Ô∏è Cr√©ativit√©] Id√©e ignor√©e car invalide: {strategy}")
                continue
            mapping = self._apply_mapping_strategy(source_domain, target_domain, strategy)
            mappings.append(mapping)
        
        return mappings
    
    def _apply_mapping_strategy(self, source: str, target: str, strategy: str) -> str:
        """Applique une strat√©gie de mapping sp√©cifique"""
        if strategy == "structure":
            return f"Structure de {source} appliqu√©e √† {target}"
        elif strategy == "function":
            return f"Fonction de {source} transf√©r√©e √† {target}"
        elif strategy == "process":
            return f"Processus de {source} adapt√© √† {target}"
        else:
            return f"Mapping g√©n√©rique entre {source} et {target}"

class EmergentStructureDetector:
    """D√©tecteur de structure √©mergente"""
    
    def __init__(self):
        self.pattern_library = [
            "auto_organisation",
            "boucle_feedback",
            "hi√©rarchie_√©mergente",
            "r√©seau_complexe"
        ]
    
    def detect_emergent_patterns(self, blend: Dict) -> List[str]:
        """D√©tecte les patterns √©mergents dans un blend"""
        detected_patterns = []
        
        # D√©tection bas√©e sur les caract√©ristiques du blend
        if len(blend.get("elements", [])) >= 4:
            detected_patterns.append("complexit√©_√©mergente")
        
        if len(blend.get("relations", [])) >= 3:
            detected_patterns.append("interconnexion_√©mergente")
        
        # Patterns de la librairie
        if random.random() < 0.3:
            detected_patterns.append(random.choice(self.pattern_library))
        
        return detected_patterns

class BlendEvaluator:
    """√âvaluateur de blends conceptuels"""
    
    def __init__(self):
        self.evaluation_criteria = {
            "coherence": 0.6,
            "richness": 0.7,
            "novelty": 0.8,
            "utility": 0.5
        }
    
    def evaluate_blend(self, blend: Dict) -> Dict[str, float]:
        """√âvalue un blend conceptuel"""
        scores = {}
        
        # Coh√©rence
if isinstance(scores, dict):
    scores['coherence'] = self._assess_coherence(blend)
else:
    setattr(scores, 'coherence', self._assess_coherence(blend))
        
        # Richesse
if isinstance(scores, dict):
    scores['richness'] = self._assess_richness(blend)
else:
    setattr(scores, 'richness', self._assess_richness(blend))
        
        # Nouveaut√©
if isinstance(scores, dict):
    scores['novelty'] = self._assess_novelty(blend)
else:
    setattr(scores, 'novelty', self._assess_novelty(blend))
        
        # Utilit√©
if isinstance(scores, dict):
    scores['utility'] = self._assess_utility(blend)
else:
    setattr(scores, 'utility', self._assess_utility(blend))
        
        # Score global
if isinstance(scores, dict):
    scores['overall'] = sum(scores.values()) / len(scores)
else:
    setattr(scores, 'overall', sum(scores.values()) / len(scores))
        
        return scores
    
    def _assess_coherence(self, blend: Dict) -> float:
        """√âvalue la coh√©rence du blend"""
        elements = blend.get("elements", [])
        relations = blend.get("relations", [])
        
        if not elements:
            return 0.3
        
        # Coh√©rence bas√©e sur la densit√© relationnelle
        coherence = min(len(relations) / max(len(elements), 1), 1.0)
        return coherence
    
    def _assess_richness(self, blend: Dict) -> float:
        """√âvalue la richesse du blend"""
        component_counts = [
            len(blend.get("elements", [])),
            len(blend.get("relations", [])),
            len(blend.get("properties", [])),
            len(blend.get("emergent_structure", []))
        ]
        
        richness = sum(component_counts) / 20.0  # Normalisation
        return min(richness, 1.0)
    
    def _assess_novelty(self, blend: Dict) -> float:
        """√âvalue la nouveaut√© du blend"""
        # Nouveaut√© bas√©e sur la structure √©mergente
        emergent_count = len(blend.get("emergent_structure", []))
        novelty = emergent_count / 5.0  # Normalisation
        
        return min(novelty, 1.0)
    
    def _assess_utility(self, blend: Dict) -> float:
        """√âvalue l'utilit√© potentielle du blend"""
        # Utilit√© estim√©e bas√©e sur la complexit√©
        complexity = sum([
            len(blend.get("elements", [])),
            len(blend.get("relations", [])),
            len(blend.get("properties", []))
        ]) / 15.0
        
        return min(complexity, 1.0)

class IncubationMonitor:
    """Moniteur de phase d'incubation"""
    
    def __init__(self):
        self.incubating_ideas = []
        self.incubation_durations = []
    
    def monitor_incubation_progress(self, ideas: List[CreativeIdea]) -> List[CreativeIdea]:
        """Surveille le progr√®s des id√©es en incubation"""
        matured_ideas = []
        
        for idea in ideas:
            if self._is_ready_for_illumination(idea):
                matured_ideas.append(idea)
        
        return matured_ideas
    
    def _is_ready_for_illumination(self, idea: CreativeIdea) -> bool:
        """D√©termine si une id√©e est pr√™te pour l'illumination"""
        incubation_time = time.time() - idea.created_time
        activation = idea.activation_level
        
        # Pr√™t si activation √©lev√©e et temps d'incubation suffisant
        return activation > 0.7 and incubation_time > 30.0

class InsightTriggerSystem:
    """Syst√®me de d√©clenchement d'insights"""
    
    def __init__(self):
        self.triggers = [
            "pattern_completion",
            "contradiction_resolution",
            "perspective_shift",
            "constraint_relaxation"
        ]
    
    def check_trigger_conditions(self, creative_state: Dict) -> bool:
        """V√©rifie les conditions de d√©clenchement d'insight"""
        conditions_met = 0
        
        if creative_state.get("creative_flow", 0) > 0.6:
            conditions_met += 1
        
        if creative_state.get("cognitive_flexibility", 0) > 0.5:
            conditions_met += 1
        
        if creative_state.get("inspiration_level", 0) > 0.4:
            conditions_met += 1
        
        return conditions_met >= 2

class AhaMomentDetector:
    """D√©tecteur de moments 'Aha!'"""
    
    def __init__(self):
        self.aha_indicators = [
            "sudden_clarity",
            "emotional_peak",
            "cognitive_shift",
            "solution_emergence"
        ]
    
    def detect_aha_moment(self, insight: CreativeInsight) -> bool:
        """D√©tecte un v√©ritable moment 'Aha!'"""
        aha_score = (
            insight.clarity +
            insight.surprise +
            insight.emotional_intensity
        ) / 3.0
        
        return aha_score > 0.7

class InsightVerificationSystem:
    """Syst√®me de v√©rification des insights"""
    
    def __init__(self):
        self.verification_methods = [
            "logical_consistency",
            "empirical_testing",
            "expert_review",
            "predictive_power"
        ]
    
    def verify_insight(self, insight: CreativeInsight) -> str:
        """V√©rifie la validit√© d'un insight"""
        # Simulation de v√©rification
        verification_score = random.uniform(0.0, 1.0)
        
        if verification_score > 0.7:
            return "verified"
        elif verification_score > 0.3:
            return "partially_verified"
        else:
            return "falsified"

class InnovationProjectManager:
    """Gestionnaire de projets d'innovation"""
    
    def __init__(self):
        self.project_templates = {}
        self.success_factors = []
    
    def manage_project_progress(self, project: InnovationProject) -> InnovationProject:
        """G√®re le progr√®s d'un projet d'innovation"""
        # Simulation d'avancement
        if project.current_phase < len(project.development_phases):
            progress_chance = random.uniform(0.1, 0.3)
            if random.random() < progress_chance:
                project.current_phase += 1
        
        return project

class DevelopmentPlanner:
    """Planificateur de d√©veloppement"""
    
    def __init__(self):
        self.planning_heuristics = [
            "sequential_development",
            "parallel_processing",
            "iterative_refinement",
            "risk_mitigation"
        ]
    
    def create_development_plan(self, core_idea: str) -> List[Dict]:
        """Cr√©e un plan de d√©veloppement pour une id√©e"""
        phases = []
        
        # Phases standard
        standard_phases = [
            {"name": "conceptualization", "duration": 7, "resources": ["brainstorming", "research"]},
            {"name": "prototyping", "duration": 14, "resources": ["design", "testing"]},
            {"name": "refinement", "duration": 10, "resources": ["feedback", "iteration"]},
            {"name": "implementation", "duration": 21, "resources": ["deployment", "documentation"]}
        ]
        
        # Ajustement bas√© sur la complexit√© de l'id√©e
        complexity = len(core_idea.split()) / 10.0
        for phase in standard_phases:
            adjusted_phase = phase.copy()
if isinstance(adjusted_phase, dict):
    adjusted_phase['duration'] = int((phase["duration"] if isinstance(phase, dict) else getattr(phase, "duration", None)) * (1 + complexity))
else:
    setattr(adjusted_phase, 'duration', int((phase["duration"] if isinstance(phase, dict) else getattr(phase, "duration", None)) * (1 + complexity)))
            phases.append(adjusted_phase)
        
        return phases

class InnovationRiskAssessor:
    """√âvaluateur de risques d'innovation"""
    
    def __init__(self):
        self.risk_categories = [
            "technical",
            "market",
            "resource",
            "timing"
        ]
    
    def assess_innovation_risks(self, idea: CreativeIdea) -> Dict[str, float]:
        """√âvalue les risques d'innovation"""
        risks = {}
        
        for category in self.risk_categories:
        if isinstance(category, str):
            try:
                category = {"raw_text": category}
            except Exception:
                print(f"[‚ö†Ô∏è Cr√©ativit√©] Id√©e ignor√©e car invalide: {category}")
                continue
            # √âvaluation bas√©e sur les caract√©ristiques de l'id√©e
            if category == "technical":
                risks[category] = 1.0 - idea.feasibility
            elif category == "market":
                risks[category] = 0.5  # Estimation g√©n√©rique
            elif category == "resource":
                risks[category] = (1.0 - idea.feasibility) * 0.7
            elif category == "timing":
                risks[category] = random.uniform(0.3, 0.8)
        
        return risks

class CollaborationSimulator:
    """Simulateur de collaboration cr√©ative"""
    
    def __init__(self):
        self.team_roles = ["ideator", "critic", "synthesizer", "implementer"]
        self.collaboration_patterns = [
            "brainstorming_session",
            "critical_review",
            "synthesis_meeting",
            "implementation_planning"
        ]
    
    def simulate_collaboration(self, project: InnovationProject) -> Dict[str, Any]:
        """Simule une session de collaboration"""
        collaboration = {
            "session_type": random.choice(self.collaboration_patterns),
            "participants": random.sample(self.team_roles, 2),
            "outcomes": [],
            "improvements": random.uniform(0.1, 0.3)
        }
        
        # G√©n√©ration d'outcomes simul√©s
        outcome_types = ["new_ideas", "refinements", "problem_solutions", "efficiency_gains"]
if isinstance(collaboration, dict):
    collaboration['outcomes'] = random.sample(outcome_types, 2)
else:
    setattr(collaboration, 'outcomes', random.sample(outcome_types, 2))
        
        return collaboration

class PreparationPhase:
    """Phase de pr√©paration cr√©ative"""
    
    def __init__(self):
        self.knowledge_acquisition = 0.0
        self.problem_definition = 0.0
        self.constraint_analysis = 0.0
    
    def execute(self, context: Dict) -> Dict[str, Any]:
        """Ex√©cute la phase de pr√©paration"""
        return {
            "status": "completed",
            "knowledge_acquired": random.uniform(0.5, 0.8),
            "problem_clarity": random.uniform(0.6, 0.9),
            "constraints_understood": random.uniform(0.7, 1.0)
        }

class IncubationPhase:
    """Phase d'incubation"""
    
    def __init__(self):
        self.duration = 0.0
        self.activation_level = 0.0
    
    def execute(self, ideas: List[CreativeIdea]) -> List[CreativeIdea]:
        """Ex√©cute la phase d'incubation"""
        incubated_ideas = []
        
        for idea in ideas:
            # Augmentation de l'activation pendant l'incubation
            incubation_boost = random.uniform(0.05, 0.15)
            idea.activation_level = min(1.0, idea.activation_level + incubation_boost)
            incubated_ideas.append(idea)
        
        return incubated_ideas

class IlluminationPhase:
    """Phase d'illumination"""
    
    def __init__(self):
        self.insight_intensity = 0.0
        self.solution_clarity = 0.0
    
    def execute(self, incubated_ideas: List[CreativeIdea]) -> Optional[CreativeInsight]:
        """Ex√©cute la phase d'illumination"""
        if not incubated_ideas:
            return None
        
        # S√©lection de l'id√©e la plus activ√©e
        best_idea = max(incubated_ideas, key=lambda x: x.activation_level)
        
        if best_idea.activation_level > 0.7:
            # Cr√©ation d'un insight
            insight = CreativeInsight(
                insight_id=f"insight_{int(time.time())}",
                type=InsightType.EMERGENT,
                content=f"Solution √©mergente pour {best_idea.concept_core}",
                significance=best_idea.activation_level,
                clarity=random.uniform(0.7, 0.9),
                surprise=random.uniform(0.6, 0.8),
                emotional_intensity=random.uniform(0.5, 0.7),
                preceding_incubation=time.time() - best_idea.created_time,
                trigger="activation_peak",
                timestamp=time.time(),
                related_ideas=[best_idea.id],
                verification_status="unverified"
            )
            
            return insight
        
        return None

class VerificationPhase:
    """Phase de v√©rification"""
    
    def __init__(self):
        self.validation_methods = [
            "logical_analysis",
            "practical_testing",
            "expert_evaluation"
        ]
    
    def execute(self, insight: CreativeInsight) -> str:
        """Ex√©cute la phase de v√©rification"""
        # Simulation de v√©rification
        verification_score = random.uniform(0.0, 1.0)
        
        if verification_score > 0.8:
            return "fully_validated"
        elif verification_score > 0.5:
            return "partially_validated"
        else:
            return "invalidated"

# Test du syst√®me de cr√©ativit√©
if __name__ == "__main__":
    print("üé® TEST DU SYST√àME DE CR√âATIVIT√â")
    print("=" * 50)
    
    # Cr√©ation du syst√®me
    creativity_system = CreativitySystem()
    
    # Test de g√©n√©ration d'id√©es
    print("\nüí° Test de g√©n√©ration d'id√©es:")
    ideas = creativity_system.generate_ideas(
        topic="transport urbain",
        constraints=["√©cologique", "accessible", "efficace"],
        num_ideas=5,
        strategy="auto"
    )
    
    for i, idea in enumerate(ideas, 1):
        print(f"{i}. {idea.concept_core}")
        print(f")  # Novelty: {idea.novelty:.2f}, Utility: {idea.usefulness:.2f}, Feasibility: {idea.feasibility:.2f}")
    
    # Test de m√©lange conceptuel
    print("\nüîÑ Test de m√©lange conceptuel:")
    blend = creativity_system.create_conceptual_blend("v√©lo", "nuage")
    print(f"Blend: {blend.blended_space}")
    print(f"Cr√©ativit√©: {blend.creativity_score:.2f}, Coh√©rence: {blend.coherence:.2f}")
    
    # Test d'insight
    print("\nüí´ Test d'insight cr√©atif:")
    insight = creativity_system.experience_insight({
        "problem": "am√©liorer l'efficacit√© √©nerg√©tique des b√¢timents"
    })
    
    if insight:
        print(f"Insight: {insight.content}")
        print(f"Type: {insight.type.value}, Signification: {insight.significance:.2f}")
    
    # Test de projet d'innovation
    print("\nüöÄ Test de projet d'innovation:")
    project = creativity_system.develop_innovation_project(
        core_idea="syst√®me de transport urbain √©cologique",
        objectives=["r√©duire les √©missions", "am√©liorer la mobilit√©", "√™tre abordable"],
        constraints=["budget limit√©", "infrastructure existante"]
    )
    
    print(f"Projet: {project.core_idea}")
    print(f"Phases: {len(project.development_phases)}, Risques: {len(project.risk_assessment)}")
    
    # Statut final
    print("\nüìä Statut cr√©atif complet:")
    status = creativity_system.get_creative_status()
    for key, value in status.items():
        if isinstance(value, dict):
            print(f" - {key}:")
            for subkey, subvalue in value.items():
                print(f"   - {subkey}: {subvalue}")
        else:
            print(f" - {key}: {value}")
    
    # Arr√™t propre
    creativity_system.stop_creativity_system()
    
    print("\n‚úÖ Test du syst√®me de cr√©ativit√© termin√© avec succ√®s!")